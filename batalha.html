<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <title>Minigame Batalha</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        /* tela cheia, sem margens */

        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        /* canvas ocupa toda a janela */

        #gameCanvas {
            display: block;
            background: #654321;
            /* marrom escuro para a ilha */
            cursor: grab;
        }

        /* menu de dificuldade centralizado */

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-family: sans-serif;
        }

        #menu button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        /* Painel inferior de sele√ß√£o */

        #troopPanel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            padding: 8px;
            justify-content: center;
        }

        .troop-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 8px;
            cursor: pointer;
            color: white;
            font-family: sans-serif;
        }

        .troop-btn img {
            width: 48px;
            height: 48px;
            margin-bottom: 4px;
        }

        .troop-btn.selected {
            outline: 2px solid #ffd700;
            border-radius: 4px;
        }

        /* Barra de vida */

        .hp-bar {
            position: absolute;
            height: 6px;
            background: gray;
        }

        .hp-fill {
            height: 100%;
        }

        #powerup-shop {
            display: flex;
            gap: 16px;
            /* espa√ßo entre cada powerup */
            justify-content: center;
        }

        .powerup {
            display: flex;
            flex-direction: column;
            /* empilha bot√£o + texto verticalmente */
            align-items: center;
            /* centraliza no eixo horizontal */
        }

        .powerup-cost {
            font-size: 8px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            color: rgb(0, 170, 255);
            text-align: center;
            margin-top: 4px;
        }

        #shop {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            color: #fff;
            font-family: sans-serif;
            display: none;
            z-index: 999;
        }

        .btn-voltar {
            position: absolute;
            top: 10px;
            /* 30px para baixo */
            left: 228px;
            /* 228px da borda esquerda */
            z-index: 1000;
            /* acima do canvas */

            display: inline-block;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            cursor: pointer;
        }


        .btn-voltar:hover {
            background: #45A049;
        }


        @media (max-width: 950px),
        (max-height: 450px) {
            #gameCanvas {
                width: 100vw !important;
                height: 100vh !important;
                box-sizing: border-box;
            }

            #zoomContainer button {
                font-size: 16px !important;
                width: 30px !important;
                height: 30px !important;
            }

            #zoomContainer {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 4px;
            }

            #troopPanel {
                flex-wrap: wrap;
                font-size: 18px;
            }

            .troop-btn img {
                width: 64px;
                height: 64px;
            }

            #btnCancel {
                font-size: 18px;
                padding: 12px 24px;
            }

            #shop {
                top: 47%;
                padding: 5px;
            }

            #powerup-shop {
                gap: 11px;
                /* antes era 16px, agora 16‚Äì5=11 */
            }

            /* reduz o tamanho dos √≠cones (bot√µes) */
            .powerup button img {
                width: 27px;
                /* antes 32px, agora 32‚Äì5=27 */
                height: 27px;
                /* mesmo valor em height */
            }

            /* reduz a fonte do custo */
            .powerup-cost {
                font-size: 8px;
                /* antes 8px, agora 8‚Äì5=3 */
                margin-top: 2px;
                /* ajusta espa√ßamento se quiser */
            }

            #shop h3 {
                margin-bottom: 4px;
                /* ou 0, se quiser colar */
            }

            /* 2) Ajusta a dist√¢ncia entre o h3 e o #powerup-shop */
            #shop h3+#powerup-shop {
                margin-top: 3px;
                /* valor = (dist√¢ncia atual) - 7px */
            }
        }

        @media (max-width: 900px) and (max-height: 415px) {

            /* ‚Üì Ajuste o valor de top at√© encontrar a posi√ß√£o ideal */
            #shop {
                top: 47% !important;
            }
        }

        /* Breakpoint extra pequeno: ajuda quem ainda usa J1 mini, Galaxy S8+ no modo paisagem apertado, etc */
        @media (max-width: 790px) and (max-height: 390px) {

            /* 1) Painel de tropa: encolhe o font-size geral e gap */
            #troopPanel {
                font-size: 14px !important;
                /* antes 18px */
                gap: 4px !important;
                /* reduz espa√ßamento interno */
            }

            /* 2) Bot√µes de tropa: reduz o tamanho das imagens */
            .troop-btn img {
                width: 48px !important;
                /* antes 64px */
                height: 48px !important;
            }

            /* 3) Bot√£o de cancelar: diminui padding e fonte */
            #btnCancel {
                font-size: 14px !important;
                /* antes 18px */
                padding: 8px 16px !important;
                /* antes 12px 24px */
            }

            /* 4) Loja de Power-Ups: encolhe tudo */
            #powerup-shop {
                gap: 8px !important;
                /* antes 11px */
            }

            .powerup button img {
                width: 22px !important;
                /* antes 27px */
                height: 22px !important;
            }

            .powerup-cost {
                font-size: 6px !important;
                /* antes 8px */
                margin-top: 1px !important;
            }

            /* 5) Ajusta posi√ß√£o do #shop se precisar ‚Äúbaixar‚Äù ainda mais */
            #shop {
                top: 47% !important;
                /* experimente valores entre 75‚Äì85% */
                padding: 4px !important;
                /* um pouco menos de padding */
                transform: scale(0.8) translate(-50%, -50%) !important;
                transform-origin: top center;
            }

            /* 6) T√≠tulo da loja: aproxima ainda mais do conte√∫do */
            #shop h3 {
                margin-bottom: 2px !important;
            }

            #shop h3+#powerup-shop {
                margin-top: 1px !important;
            }

            /* ‚Üì Adiciona estas regras para "encolher" os bot√µes de upgrade */
            #upgrades button {
                font-size: 10px !important;
                /* diminui o texto */
                padding: 4px 8px !important;
                /* reduz o padding */
                min-width: 0 !important;
                /* deixa largura conforme o conte√∫do */
                margin: 2px !important;
                /* um espacinho entre eles */
            }

            /* Se quiser ainda controlar o container */
            #upgrades {
                display: flex;
                flex-wrap: wrap;
                gap: 3px !important;
            }

            #shop #upgrades button {
                font-size: 10px !important;
                /* texto menor */
                padding: 4px 6px !important;
                /* padding bem enxuto */
                min-width: 0 !important;
                /* sem largura m√≠nima */
                margin: 2px !important;
                /* espacinho entre eles */
                transform-origin: top left;
                transform: scale(0.8) !important;
            }

            /* opcional: se quiser encolher o texto ‚ÄúEvoluir (‚Ä¶)‚Äù */
            #shop #upgrades button[data-evo] {
                font-size: 9px !important;
            }
        }

        /* Pocket mode ‚Äì telas muito pequenas */
        @media (max-width: 576px),
        (max-height: 348px) {
            #troopPanel {
                padding: 6px !important;
                /* antes era 8px */
                font-size: 12px !important;
                /* antes 14‚Äì18px */
            }

            .troop-btn {
                margin: 0 6px !important;
                /* antes 8px */
            }

            .troop-btn img {
                width: 46px !important;
                /* antes 48px */
                height: 46px !important;
            }

            #btnCancel {
                font-size: 12px !important;
                padding: 6px 14px !important;
                /* antes 8px 16px */
            }

            #zoomContainer button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }

            /* Ajustes para a loja e powerups */
            #shop {
                transform: scale(0.7) translate(-50%, -50%) !important;
            }

            #powerup-shop {
                gap: 6px !important;
                /* antes 8‚Äì11px */
            }

            .powerup button img {
                width: 20px !important;
                /* antes 22‚Äì27px */
                height: 20px !important;
            }

            .powerup-cost {
                font-size: 6px !important;
                /* antes 6‚Äì8px */
                margin-top: 0 !important;
            }
        }



        #zoomContainer {
            position: absolute;
            top: 40px;
            right: 10px;
            z-index: 2000;
        }

        #zoomContainer button {
            font-size: 16px;
            width: 30px;
            height: 30px;
            margin: 2px;
        }
    </style>
</head>

<body>
    <!-- canvas do jogo -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <button id="btnToggleShop"
        style="position: absolute; top: 50%; right: 0; transform: translateY(-50%);padding: 10px; font-size: 16px; z-index: 1000;">
        Loja
    </button>

    <!-- menu de sele√ß√£o de dificuldade -->
    <div id="menu">
        <h2>Escolha a Dificuldade</h2>
        <button data-diff="easy">F√°cil</button>
        <button data-diff="medium">M√©dio</button>
        <button data-diff="hard">Hard</button>
        <button data-diff="insane" id="btnInsane"
            style="background:#c00;color:#fff;display:inline-flex;align-items:center;">
            Insano
            <img src="https://cdn-icons-png.flaticon.com/512/487/487884.png" width="22"
                style="margin-left:6px;filter:drop-shadow(0 0 2px #000);">
        </button>
    </div>

    <div id="troopPanel">
        <!-- Os bot√µes ser√£o gerados via JS -->
        <button id="btnCancel" style="margin-left: 16px">Cancelar Compra</button>
    </div>

    <div id="shop">
        <h3>Loja</h3>
        <div id="upgrades"></div>
        <h3>Loja de Power-Ups</h3>
        <div id="powerup-shop">
            <div class="powerup">
                <button id="btn-bomba">
                    <img src="https://static.thenounproject.com/png/2651796-200.png" width="32">
                </button>
                <div class="powerup-cost">7 Elixir</div>
            </div>
            <div class="powerup">
                <button id="btn-cura">
                    <img src="https://images.vexels.com/media/users/3/354131/isolated/preview/4fe7858f34cdd0cdba3ff384b80d246d-pixel-art-coracao-vermelho.png"
                        width="32">
                </button>
                <div class="powerup-cost">5 Elixir</div>
            </div>
            <div class="powerup">
                <button id="btn-congelar">
                    <img src="https://png.pngtree.com/png-vector/20230828/ourmid/pngtree-flat-snowflake-icon-with-lots-of-lines-vector-png-image_6946228.png"
                        width="32">
                </button>
                <div class="powerup-cost">16 Elixir</div>
            </div>
        </div>

    </div>

    <button id="btnModMenu" style="position:fixed;left:10px;bottom:80px;z-index:2000;display:none;">Abrir
        ModMenu</button>

    <!-- Bot√£o de Ajuda no topo central -->
    <button id="btnAjuda" style="
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 12px;
    font-size: 14px;
    background: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
    z-index: 1000;
    cursor: pointer;
  ">
        ‚ùì Ajuda
    </button>

    <a href="index.html" class="btn-voltar">‚Üê Voltar ao Jogo</a>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const btnBomba = document.getElementById("btn-bomba");
        const btnCura = document.getElementById("btn-cura");
        const btnCongelar = document.getElementById("btn-congelar");

        // Tamanho do mundo
        const WORLD_SIZE = 2600;

        // Posi√ß√µes dos castelos
        const castles = {
            green: {
                x: WORLD_SIZE - 100,
                y: WORLD_SIZE / 2,
                hp: 3000,
                maxHp: 3000,
            },
            red: {
                x: 100,
                y: WORLD_SIZE / 2,
                hp: 3000,
                maxHp: 3000,
            },
        };

        // Estado da c√¢mera
        const camera = {
            x: 0,
            y: 0,
            dragging: false,
            lastX: 0,
            lastY: 0,
        };

        const projectiles = [];

        let hardMode = false;

        // Para controlar regenera√ß√£o
        castles.red.lastHitTime = 0;

        let nextTroopId = 1;


        /**
         * Explode em (x,y) numa √°rea quadrada de size√ósize,
         * causando `dmg` a todas as tropas de `targets`.
         * Se alguma morrer, recompensa normalmente.
         */
        function explodeAt(x, y, size, dmg, targets) {
            const half = size / 2;
            targets.forEach((t, i) => {
                if (t.x >= x - half && t.x <= x + half && t.y >= y - half && t.y <= y + half) {
                    const killed = applyDamage(t, dmg);
                    // se morreu, j√° fizemos applyDamage e removemos da lista l√°,
                    // ent√£o recompensa normal de kill (j√° est√° na l√≥gica de applyDamage).
                }
            });

            // Se o castelo inimigo estiver na √°rea, tamb√©m toma dano:
            [castles.green, castles.red].forEach((c) => {
                if (
                    c.hp > 0 &&
                    c.x >= x - half &&
                    c.x <= x + half &&
                    c.y >= y - half &&
                    c.y <= y + half
                ) {
                    c.hp = Math.max(0, c.hp - dmg);
                    checkEndConditions();
                }
            });
        }


        function applyDamage(unit, dmg) {
            const wasAlive = unit.hp > 0;
            unit.hp = Math.max(0, unit.hp - dmg);
            if (unit.type === "curador" && unit.isEvo) {
                unit.lastAttackedAt = performance.now();
            }
            const died = wasAlive && unit.hp === 0;
            if (died) {
                if (enemies.includes(unit)) {
                    elixir += rewardElixir[unit.type] || 0;
                }


                // Explos√£o caso fosse um golem inimigo
                if (unit.type === "golem") {
                    explodeAt(unit.x, unit.y, 90, 100, unit === castles.green ? enemies : allies);
                }

                // Remove da lista
                const idxA = allies.indexOf(unit);
                if (idxA !== -1) {
                    allies.splice(idxA, 1);
                    return true;
                }
                const idxE = enemies.indexOf(unit);
                if (idxE !== -1) {
                    enemies.splice(idxE, 1);
                    return true;
                }
            }
            return false;
        }

        let hardModeFlags = {
            spawnedAt50: false,
            spawnedAt20: false
        };

        function checkHardModeTriggers() {
            const castle = castles.red;
            const pct = castle.hp / castle.maxHp;

            // ‚â§ 50% de vida ‚Äî uma vez
            if (hardMode && !hardModeFlags.spawnedAt50 && pct <= 0.5) {
                hardModeFlags.spawnedAt50 = true;
                // gera 1 espadachim
                spawnEnemyInstant("espadachim");
                // gera 1 curadora evolu√≠da
                spawnEnemyInstant("curador", { evolved: true });
            }

            // ‚â§ 20% de vida ‚Äî uma vez
            if (hardMode && !hardModeFlags.spawnedAt20 && pct <= 0.2) {
                hardModeFlags.spawnedAt20 = true;
                // gera 1 golem
                spawnEnemyInstant("golem");
                // gera 1 mago
                spawnEnemyInstant("mago");
            }
        }



        // Preload das imagens
        const castleImg = new Image();
        castleImg.src =
            "https://cdn.pixabay.com/photo/2022/09/08/11/36/castle-7440761_1280.png";
        castleImg.onload = () => {
            castles.green.img = castleImg;
            castles.red.img = castleImg;
            draw(performance.now(), ctx);
        };

        let money = 200;
        let selectedType = null;

        let elixir = 0;
        const rewardElixir = {
            arqueiro: 1,
            mago: 2,
            espadachim: 4,
            golem: 5,
            assassino: 2,
            curador: 3,
            chefe: 10,
        };

        // ‚îÄ‚îÄ‚îÄ Power-Up Definitions ‚îÄ‚îÄ‚îÄ
        const powerUpDefs = {
            bomba: {
                cost: 7,
                cd: 20000,           // 20 s em ms
                imgSrc: "https://static.thenounproject.com/png/2651796-200.png",
                range: 200,
                delay: 3000,         // 3 s at√© explodir
                damage: 1600,
                towerDmgDiv: 5
            },
            cura: {
                cost: 5,
                cd: 15000,           // 15 s
                imgSrc: "https://images.vexels.com/media/users/3/354131/isolated/preview/4fe7858f34cdd0cdba3ff384b80d246d-pixel-art-coracao-vermelho.png",
                range: 220,
                duration: 10000,     // 10 s
                healPerSec: 100
            },
            congelar: { // NOVO POWERUP
                cost: 16,
                cd: 40000,
                imgSrc: "https://png.pngtree.com/png-vector/20230828/ourmid/pngtree-flat-snowflake-icon-with-lots-of-lines-vector-png-image_6946228.png",
                range: 300,
                freezeDuration: 12000, // 12s
                slowDuration: 6000,    // 6s
                slowFactor: 0.2,       // 80% mais lento (20% da velocidade)
                effectColor: "rgb(0, 170, 255)"
            }
        };

        const imgBomba = new Image();
        imgBomba.src = powerUpDefs.bomba.imgSrc;
        const imgCura = new Image();
        imgCura.src = powerUpDefs.cura.imgSrc;
        const imgCongelar = new Image();
        imgCongelar.src = powerUpDefs.congelar.imgSrc;

        let imgBombaLoaded = false;
        imgBomba.onload = () => {
            imgBombaLoaded = true;
            draw(); // for√ßa redesenho quando carregar
        };

        let imgCuraLoaded = false;
        imgCura.onload = () => {
            imgCuraLoaded = true;
            draw(); // for√ßa redesenho quando carregar
        };

        let imgCongelarLoaded = false;
        imgCongelar.onload = () => {
            imgCongelarLoaded = true;
            draw();
        };

        let selectedPowerUp = null;
        const powerUpState = {
            bomba: { lastUsed: -Infinity },
            cura: { lastUsed: -Infinity },
            congelar: { lastUsed: -Infinity }
        };

        const activeFreezes = [];

        // --- Troop definitions ---
        const troopDefs = {
            arqueiro: {
                name: "Arqueiro",
                cost: 70,
                hp: 250,
                maxHp: 250,
                range: 410,
                damage: 150,
                attackSpeed: 4500,
                speed: 60, // pixels por segundo
                imgSrc: "https://images.vexels.com/media/users/3/249193/isolated/preview/6594b2dcb1518684a963eda9cc61b6e8-personagens-de-chibi-de-tiro-com-arco-7.png",
            },
            espadachim: {
                name: "Espadachim",
                cost: 50,
                hp: 1200,
                maxHp: 1200,
                range: 15,
                damage: 80,
                attackSpeed: 1000,
                speed: 120, // mais r√°pido, estilo melee
                imgSrc: "https://img.freepik.com/fotos-premium/samurai-ronin-com-armadura-tradicional-e-katana-homem-teen-ta-cute-guerreiro-ilustracao-de-personagem_1020495-735514.jpg",
            },
            curador: {
                name: "Curador",
                cost: 120,
                hp: 300,
                maxHp: 300,
                range: 250,
                damage: 25,
                heal: 150,
                attackSpeed: 1000,
                speed: 50, // mais lento
                imgSrc: "https://cdn.pixabay.com/photo/2024/05/28/09/11/woman-8793320_1280.png",
            },
            mago: {
                name: "Mago",
                cost: 110,
                hp: 150,
                maxHp: 150,
                range: 300,
                damage: 300,
                attackSpeed: 3000,
                speed: 80, // moderado
                imgSrc: "https://static.vecteezy.com/system/resources/previews/055/136/141/non_2x/chibi-wizard-casting-spells-in-enchanted-forest-digital-art-fantasy-whimsical-viewpoint-free-png.png",
            },
            assassino: {
                name: "Assassino",
                cost: 100,
                hp: 400,
                maxHp: 400,
                range: 15,
                damage: 80,
                attackSpeed: 1000,
                speed: 150, // r√°pido
                imgSrc: "https://images.vexels.com/media/users/3/266496/isolated/preview/f87a7beb11d5fdda3c8fc39990d0823b-ceifador-kawaii-de-halloween.png",
            },
            golem: {
                name: "Golem",
                cost: 230,
                hp: 2400,
                maxHp: 2400,
                range: 30, // corpo-a-corpo at√© 30px
                damage: 200,
                attackSpeed: 1500, // tempo entre ataques (ajuste a gosto)
                speed: 25,
                imgSrc: "https://www.pngplay.com/wp-content/uploads/11/Golem-Pokemon-PNG-Clipart-Background.png"
            },
            chefe: {
                name: "Chefe",
                cost: 550,
                hp: 5000,
                maxHp: 5000,
                range: 40,                   // corpo a corpo at√© 40px
                damage: 300,                 // por segundo
                // para 300 DPS, use attackSpeed = 1000ms e aplique dano proporcional:
                attackSpeed: 1000,
                speed: 25, // mesma velocidade do golem
                imgSrc: "https://cdn-icons-png.flaticon.com/256/2790/2790435.png",
            },

            esqueleto: {
                name: "Esqueleto",
                cost: 0,
                hp: 150,
                maxHp: 150,
                range: 15,
                damage: 40,        // por segundo
                attackSpeed: 1000, // 1s entre ataques (40 DPS)
                speed: 130,
                imgSrc: "https://static.vecteezy.com/system/resources/previews/047/739/546/non_2x/skeleton-warrior-with-a-red-hood-png.png",
            },
        };

        // slots onde o jogador pode construir torres
        const towerSlots = [
            // Slots do castelo verde (alinhados na horizontal √† esquerda)
            { x: castles.green.x - 80, y: castles.green.y, w: 60, h: 60, occupied: null },
            { x: castles.green.x - 150, y: castles.green.y, w: 60, h: 60, occupied: null },
            { x: castles.green.x - 220, y: castles.green.y, w: 60, h: 60, occupied: null },

            // Slots do castelo vermelho (√† direita do castelo inimigo)
            { x: castles.red.x + 80, y: castles.red.y, w: 60, h: 60, occupied: null },
            { x: castles.red.x + 150, y: castles.red.y, w: 60, h: 60, occupied: null },
            { x: castles.red.x + 220, y: castles.red.y, w: 60, h: 60, occupied: null },
        ];

        const imgTower = new Image();
        imgTower.src = "https://fiverr-res.cloudinary.com/images/t_smartwm/t_main1,q_auto,f_auto,q_auto,f_auto/v1/attachments/delivery/asset/b8ae8764ed4afe6f2b136bd893aaac5e-1744895032/lordpickle%20tower%20large/create-pixel-art-assests-of-your-choice.png";
        const imgHealTower = new Image();
        imgHealTower.src = "https://static.vecteezy.com/system/resources/previews/018/873/070/non_2x/crystal-curative-transparent-healing-quartz-blue-gradient-clear-bright-gem-magic-stone-png.png";
        const imgMine = new Image();
        imgMine.src = "https://images.vexels.com/media/users/3/314781/isolated/preview/ba64a07decf002fb3523e884d272711d-mining-for-gold.png";
        const imgSpawnTower = new Image();
        imgSpawnTower.src = "https://png.pngtree.com/png-clipart/20240705/original/pngtree-pet-house-in-pixel-art-style-png-image_15494000.png";
        const imgInferno = new Image();
        imgInferno.src = "https://png.pngtree.com/png-vector/20241030/ourmid/pngtree-pixelated-amethyst-crystal-formation-png-image_14194655.png";
        const imgWindTower = new Image();
        imgWindTower.src = "https://png.pngtree.com/png-vector/20230728/ourmid/pngtree-wind-turbine-vector-png-image_7005953.png";

        const imgTornado = new Image();
        imgTornado.src = "https://cdn-icons-png.freepik.com/512/12414/12414754.png";

        let imgWindLoaded = false;
        imgWindTower.onload = () => { imgWindLoaded = true; draw(); };

        let imgTornadoLoaded = false;
        imgTornado.onload = () => { imgTornadoLoaded = true; /* n√£o √© cr√≠tico redesenhar */ };

        const towerDefs = {
            tower_arqueira: {
                cost: 350,
                hp: 1800,
                maxHp: 1800,
                range: 450,
                damage: 175,
                attackSpeed: 4500, // ms
                img: imgTower
            },
            tower_curativa: {
                cost: 400,
                hp: 900,
                maxHp: 900,
                range: 310,
                damage: 25,        // dano por ataque (1s)
                heal: 150,         // cura por ataque (1s)
                attackSpeed: 1000, // 1 segundo
                img: imgHealTower
            },
            mine: {  // ‚úÖ Aqui voc√™ pode adicionar direto como propriedade
                cost: 500,
                hp: 600,
                maxHp: 600,
                goldPerTick: 100,
                tickInterval: 8000,
                img: imgMine
            },
            tower_spawner: {
                cost: 450,
                hp: 800,
                maxHp: 800,
                range: 0,           // n√£o ataca diretamente
                spawnInterval: 10000,  // 10 s
                lastSpawn: 0,
                img: imgSpawnTower
            },
            tower_inferno: {
                cost: 500,
                hp: 1500,
                maxHp: 1500,
                range: 290,
                damage: 10, // est√°gio 1
                attackSpeed: 200, // 5 hits por segundo (1000/5)
                img: imgInferno
            },
            tower_vento: {
                cost: 450,
                hp: 800,
                maxHp: 800,
                range: 350,       // alcance de engajar o proj√©til
                attackSpeed: 25000,   // 25 s em ms
                img: imgWindTower,

                // propriedades espec√≠ficas do tornado
                tornado: {
                    speed: 80,    // px/s
                    lifetime: 10000, // 10 s em ms
                    damagePerSec: 100
                }
            },
        };

        // n√≠vel de upgrade para cada tipo e cada stat
        const upgrades = {
            arqueiro: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
            espadachim: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
            curador: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
            mago: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
            assassino: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
            golem: {
                hp: 0,
                dmg: 0,
                range: 0,
                speed: 0
            },
        };

        // configura√ß√£o de evolu√ß√£o
        const evolution = {
            arqueiro: {
                cost: 1200,
                unlocked: JSON.parse(localStorage.getItem("evo_arqueiro")) || false,
                stats: {
                    hp: 410,
                    maxHp: 410,
                    range: 500,
                    damage: 220,
                    speed: 80,
                    attackSpeed: 4500 // <-- adicione isto!
                }
            },
            curador: {
                cost: 800,
                unlocked: JSON.parse(localStorage.getItem("evo_curador")) || false,
                stats: {
                    hp: 580,
                    maxHp: 580,
                    range: 350,
                    damage: 80,
                    heal: 250,
                    speed: 70,
                    attackSpeed: 1000 // <-- adicione isto!
                }
            },
            assassino: {
                cost: 1400,
                unlocked: JSON.parse(localStorage.getItem("evo_assassino")) || false,
                stats: {
                    hp: 890,
                    maxHp: 890,
                    range: 40,
                    damage: 140,           // dano base ap√≥s evolu√ß√£o
                    speed: 180,
                    firstHitDamage: 850,    // dano do primeiro ataque
                    attackSpeed: 1000 // <-- adicione isto!
                }
            }
        };

        // contador de compras em partida
        const purchaseCount = {
            arqueiro: 0,
            curador: 0,
            assassino: 0
        };


        const rewardForKill = {
            espadachim: 80,
            arqueiro: 140,
            curador: 250,
            mago: 300,
            assassino: 250,
            golem: 380,
            tower_arqueira: 200,
            tower_curativa: 275,
            tower_inferno: 330,      // NOVO
            tower_spawner: 400,
            chefe: 800,
        };

        // 2) Carregue a imagem da flecha:
        const arrowImg = new Image();
        arrowImg.src =
            "https://static.vecteezy.com/ti/vetor-gratis/p1/20407177-linha-de-seta-arco-isolada-no-fundo-branco-icone-liso-preto-fino-no-estilo-de-contorno-moderno-simbolo-linear-e-traco-editavel-ilustracaoial-de-traco-perfeito-simples-e-pixel-vetor.jpg";
        // ...ap√≥s carregar arrowImg...
        const mageBallImg = new Image();
        mageBallImg.src = "https://png.pngtree.com/png-vector/20241204/ourmid/pngtree-electric-blue-energy-ball---futuristic-design-png-image_14570095.png";




        Promise.all([
            new Promise(res => { if (arrowImg.complete) res(); else arrowImg.onload = res; }),
            new Promise(res => { if (mageBallImg.complete) res(); else mageBallImg.onload = res; })
        ]).then(() => {
            // Agora sim, s√≥ inicia o gameLoop depois das imagens carregarem!
            window.startBattleGame = function () {
                requestAnimationFrame(gameLoop);
            };
        });

        const allies = [];
        const enemies = [];

        // 3) Crie um array para projetis (setas) ‚Äì vai usar depois:


        let lastTime = 0;
        const waveDuration = 5 * 60 * 1000; // 5 minutos em ms

        btnCongelar.addEventListener("click", () => {
            selectedPowerUp = "congelar";
            document.getElementById("shop").style.display = "none";
        });

        document.getElementById("btnCancel").onclick = () => {
            document
                .querySelectorAll(".troop-btn")
                .forEach((b) => b.classList.remove("selected"));
            selectedType = null;
            selectedPowerUp = null;
        };

        function updatePowerUpButtons() {
            const now = performance.now();
            ["bomba", "cura", "congelar"].forEach(key => {
                let btn;
                if (key === "bomba") btn = btnBomba;
                else if (key === "cura") btn = btnCura;
                else if (key === "congelar") btn = btnCongelar;
                const st = powerUpState[key];
                if (now - st.lastUsed >= powerUpDefs[key].cd && elixir >= powerUpDefs[key].cost) {
                    btn.disabled = false;
                    btn.style.background = "green";
                } else {
                    btn.disabled = true;
                    btn.style.background = "gray";
                }
            });
        }

        btnBomba.addEventListener("click", () => {
            selectedPowerUp = "bomba";
            document.getElementById("shop").style.display = "none";
        });
        btnCura.addEventListener("click", () => {
            selectedPowerUp = "cura";
            document.getElementById("shop").style.display = "none";
        });

        function startGame(diff) {
            hardMode = (diff === "hard" || diff === "insane");
            castles.red.lastHitTime = performance.now();

            sessionStorage.setItem("battleDiff", diff);

            if (hardMode) {
                enemyBuildTower();
                // halve todas as recompensas
                Object.keys(rewardForKill).forEach(type => {
                    rewardForKill[type] = Math.floor(rewardForKill[type] / 2);
                });
            }

            // Insano: +100 moedas no in√≠cio
            if (diff === "insane") {
                money += 100;
            }

            const cfg = {
                easy: {
                    max: 20,
                    delay: 20000,
                    waveSizes: [5, 8, 15, 20],
                },
                medium: {
                    max: 35,
                    delay: 10000,
                    waveSizes: [7, 13, 19, 35],
                },
                hard: {
                    max: 50,
                    delay: 3000,
                    waveSizes: [15, 20, 35, 50],
                },
                insane: {
                    max: 120,
                    delay: 2000,
                    waveSizes: [50, 70, 100, 120],
                }
            }[diff];

            cfg.waveSizes.forEach((count, i) => {
                setTimeout(() => spawnWave(count, "enemy", i + 1), i * waveDuration);
            });
        }

        function spawnChefe() {
            const def = troopDefs.chefe;
            const now = performance.now();
            const boss = {
                type: "chefe",
                x: castles.red.x,
                y: castles.red.y,
                hp: def.maxHp,
                maxHp: def.maxHp,
                damage: def.damage,
                range: def.range,
                speed: def.speed,
                attackSpeed: def.attackSpeed, // <-- ADICIONE ESTA LINHA
                lastAttack: now,
                lastSkeleton: now,
                skeletonCount: 0,
                triggers: { 80: false, 60: false, 40: false, 20: false }
            };
            enemies.push(boss);
        }

        // Carrega imagens
        for (const key in troopDefs) {
            const img = new Image();
            img.src = troopDefs[key].imgSrc;
            troopDefs[key].img = img;
        }

        // --- Painel de sele√ß√£o ---
        // --- Painel de sele√ß√£o (sem o esqueleto) ---
        const panel = document.getElementById("troopPanel");
        // pega s√≥ as chaves que n√£o sejam "esqueleto"
        const troopKeys = Object.keys(troopDefs).filter(k => k !== "esqueleto");
        for (const key of troopKeys) {
            const td = troopDefs[key];
            const btn = document.createElement("div");
            btn.classList.add("troop-btn");
            btn.innerHTML = `
    <img src="${td.imgSrc}" title="${td.name}">
    <div>${td.name}</div>
    <div>${td.cost} üí∞</div>
  `;
            btn.onclick = () => {
                document.querySelectorAll(".troop-btn").forEach(b => b.classList.remove("selected"));
                btn.classList.add("selected");
                selectedType = key;
            };
            panel.appendChild(btn);
        }


        // Clique na tela => spawn allied troop at green castle
        canvas.addEventListener("click", (e) => {
            // 1) Converte a posi√ß√£o do clique para coordenadas do mundo (considerando escala e c√¢mera)
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) / scale + camera.x;
            const my = (e.clientY - rect.top) / scale + camera.y;

            // --- USO DE POWER-UP ---
            if (selectedPowerUp) {
                const key = selectedPowerUp;
                const pu = powerUpDefs[key];
                const state = powerUpState[key];
                const now = performance.now();

                if (elixir >= pu.cost && now - state.lastUsed >= pu.cd) {
                    elixir -= pu.cost;
                    state.lastUsed = now;

                    if (key === "bomba") {
                        activeBombs.push({ x: mx, y: my, startTime: now });
                    } else if (key === "cura") {
                        activeHeals.push({ x: mx, y: my, startTime: now, lastHealSec: 0 });
                    } else if (key === "congelar") {
                        activeFreezes.push({ x: mx, y: my, startTime: now });
                    }
                }
                selectedPowerUp = null;
                // Cancela sele√ß√£o visual dos bot√µes de tropa
                document.querySelectorAll(".troop-btn").forEach(b => b.classList.remove("selected"));
                return; // N√£o executa o resto do clique!
            }

            // 2) Tenta construir torre se clicou num slot livre
            for (const slot of towerSlots) {
                if (!slot.occupied &&
                    mx >= slot.x - slot.w / 2 && mx <= slot.x + slot.w / 2 &&
                    my >= slot.y - slot.h / 2 && my <= slot.y + slot.h / 2) {
                    // Apenas slots do lado verde
                    if (Math.hypot(slot.x - castles.green.x, slot.y - castles.green.y) < 300) {
                        let choice;
                        do {
                            choice = prompt(
                                "Escolha constru√ß√£o:\n" +
                                "1) Torre Arqueira   (350üí∞)\n" +
                                "2) Torre Curativa   (400üí∞)\n" +
                                "3) Mina             (500üí∞)\n" +
                                "4) Spawner Arqueiras (450üí∞)\n" +
                                "5) Torre Inferno    (500üí∞)\n" + // NOVA LINHA
                                "6) Torre de Vento     (450üí∞)\n" +
                                "H) Ajuda ‚Äî ver estat√≠sticas completas\n\n" +
                                "Digite 1, 2, 3, 4 ou H."
                            );
                            if (!choice) return;               // cancelou
                            choice = choice.trim().toUpperCase();
                            if (choice === "H") {
                                showHelp();                    // exibe alert com stats
                            }
                        } while (!["1", "2", "3", "4", "5", "6", "H"].includes(choice));

                        // choice agora √© "1", "2" ou "3"
                        let key;
                        if (choice === "1") key = "tower_arqueira";
                        else if (choice === "2") key = "tower_curativa";
                        else if (choice === "3") key = "mine";
                        else if (choice === "4") key = "tower_spawner";
                        else if (choice === "5") key = "tower_inferno"; // NOVA LINHA
                        else if (choice === "6") key = "tower_vento";

                        const def = towerDefs[key];
                        if (money < def.cost) {
                            alert("Sem moedas suficientes!");
                            return;
                        }

                        money -= def.cost;
                        slot.occupied = {
                            type: key,
                            x: slot.x,
                            y: slot.y,
                            hp: def.hp,
                            maxHp: def.maxHp,
                            range: def.range,
                            damage: def.damage,
                            heal: def.heal,
                            attackSpeed: def.attackSpeed,
                            lastAttack: performance.now(),
                            showRangeUntil: performance.now() + 10000,
                            img: def.img,
                            // rel√≥gio da Mina (undefined para torres)
                            lastGoldTick: def.goldPerTick ? performance.now() : undefined,
                            goldPerTick: def.goldPerTick,
                            tickInterval: def.tickInterval,

                            spawnInterval: def.spawnInterval,
                            lastSpawn: 0,

                            tornado: def.tornado // ‚Üê ADICIONE ESTA LINHA!
                        };
                    }

                    return; // j√° tratou clique em slot, sai do listener
                }
            }

            // 3) Se n√£o foi em slot, segue o fluxo normal de spawn de tropas:
            if (!selectedType) return;  // n√£o escolheu tropa

            const type = selectedType;
            const def = troopDefs[type];

            if (money < def.cost) {
                alert("üí∞ Dinheiro insuficiente!");
                return;
            }

            money -= def.cost;
            renderShop(); // atualiza display da loja

            // 3.1) l√≥gica de upgrades/evolu√ß√£o (igual antes)
            if (evolution[type]) {
                purchaseCount[type] = (purchaseCount[type] || 0) + 1;
            }
            const ups = upgrades[type] || { hp: 0, dmg: 0, range: 0, speed: 0 };
            const stats = { ...def };
            let hpBonus = 20;
            if (type === "golem" || type === "espadachim") hpBonus = 40;
            else if (type === "assassino" || type === "curador") hpBonus = 30;

            let isEvo = false;
            if (evolution[type]?.unlocked && purchaseCount[type] % 3 === 0) {
                Object.assign(stats, evolution[type].stats);
                isEvo = true;
            }

            stats.hp += ups.hp * hpBonus;
            stats.maxHp += ups.hp * hpBonus;
            stats.damage += ups.dmg * 10;
            stats.speed += ups.speed * 10;
            stats.range = (stats.range || 0) + ups.range * 10;

            // 3.2) cria tropa aliada
            const t = {
                type,
                x: castles.green.x,
                y: castles.green.y,
                hp: stats.hp,
                maxHp: stats.maxHp,
                damage: stats.damage,
                speed: stats.speed,
                range: stats.range,
                attackSpeed: stats.attackSpeed, // <-- ADICIONE ESTA LINHA
                lastAttack: performance.now(),
                _angle: 0,
                isEvo,
                invisible: true,   // come√ßa invis√≠vel
                firstHit: true
            };
            if (type === "assassino" && isEvo) {
                t.firstHitDamage = evolution.assassino.stats.firstHitDamage;
            }
            // Para assassino normal, aplica invisibilidade por 15s como antes
            if (type === "assassino" && !isEvo) {
                t.invisibleUntil = performance.now() + 15000;
            }

            if (type === "chefe") {
                const def = troopDefs.chefe;
                const now = performance.now();
                const boss = {
                    type: "chefe",
                    x: castles.green.x,
                    y: castles.green.y,
                    hp: def.maxHp,
                    maxHp: def.maxHp,
                    damage: def.damage,
                    range: def.range,
                    speed: def.speed,
                    attackSpeed: def.attackSpeed, // <-- ADICIONE ESTA LINHA
                    lastAttack: now,
                    _angle: 0,
                    // ‚îÄ‚îÄ‚îÄ Inicializa√ß√£o CRUCIAL ‚îÄ‚îÄ‚îÄ
                    lastSkeleton: now,
                    skeletonCount: 0,
                    triggers: { 80: false, 60: false, 40: false, 20: false }
                };
                allies.push(boss);
                document.querySelectorAll(".troop-btn").forEach(b => b.classList.remove("selected"));
                selectedType = null;
                return;
            }
            t.id = nextTroopId++; // <-- Adicione isso
            allies.push(t);

            // 3.3) limpa sele√ß√£o
            document.querySelectorAll(".troop-btn").forEach(b => b.classList.remove("selected"));
            selectedType = null;
        });

        function updateFreezes(ts) {
            const pu = powerUpDefs.congelar;
            for (let i = activeFreezes.length - 1; i >= 0; i--) {
                const fz = activeFreezes[i];
                const elapsed = ts - fz.startTime;

                // Aplica congelamento (paralisa) por freezeDuration
                if (!fz.applied) {
                    // Congela tropas inimigas
                    enemies.forEach(u => {
                        const dx = u.x - fz.x, dy = u.y - fz.y;
                        if (Math.hypot(dx, dy) <= pu.range) {
                            u.frozenUntil = fz.startTime + pu.freezeDuration;
                            u._wasFrozen = true;
                        }
                    });
                    // Congela torres inimigas (slots 3,4,5)
                    towerSlots.slice(3, 6).forEach(slot => {
                        if (slot.occupied && slot.occupied.hp > 0) {
                            const dx = slot.x - fz.x, dy = slot.y - fz.y;
                            if (Math.hypot(dx, dy) <= pu.range) {
                                slot.occupied.frozenUntil = fz.startTime + pu.freezeDuration;
                                slot.occupied._wasFrozen = true;
                            }
                        }
                    });
                    fz.applied = true;
                }

                // Ap√≥s o congelamento, aplica slow de slowDuration
                if (elapsed > pu.freezeDuration && !fz.slowApplied) {
                    enemies.forEach(u => {
                        if (u._wasFrozen && (!u.slowExpires || u.slowExpires < ts)) {
                            u.originalSpeed = troopDefs[u.type].speed;
                            u.speed = u.originalSpeed * pu.slowFactor;
                            u.slowExpires = ts + pu.slowDuration;
                        }
                    });
                    towerSlots.slice(3, 6).forEach(slot => {
                        if (slot.occupied && slot.occupied._wasFrozen && (!slot.occupied.slowExpires || slot.occupied.slowExpires < ts)) {
                            slot.occupied.slowExpires = ts + pu.slowDuration;
                        }
                    });
                    fz.slowApplied = true;
                }

                // Remove efeito visual ap√≥s slow acabar
                if (elapsed > pu.freezeDuration + pu.slowDuration) {
                    activeFreezes.splice(i, 1);
                }
            }
        }

        // ‚Üê‚Äî‚Äî‚Äî‚Äî‚Äî Fun√ß√£o de Help ‚Äî exibe stats de todas as constru√ß√µes ‚Äî‚Äî‚Äî‚Äî‚Äî‚Üí
        function showHelp() {
            const ta = towerDefs.tower_arqueira;
            const tc = towerDefs.tower_curativa;
            const m = towerDefs.mine;

            let msg = "=== Estat√≠sticas das Constru√ß√µes ===\n\n";

            msg += "üèπ Torre Arqueira\n";
            msg += `  Custo:   ${ta.cost} üí∞\n`;
            msg += `  Vida:    ${ta.hp}/${ta.maxHp}\n`;
            msg += `  Alcance: ${ta.range}\n`;
            msg += `  Dano:    ${ta.damage}\n`;
            msg += `  Vel ATK: ${ta.attackSpeed} ms\n\n`;

            msg += "üíé Torre Curativa\n";
            msg += `  Custo:   ${tc.cost} üí∞\n`;
            msg += `  Vida:    ${tc.hp}/${tc.maxHp}\n`;
            msg += `  Alcance: ${tc.range}\n`;
            msg += `  Dano:    ${tc.damage}/s\n`;
            msg += `  Cura:    ${tc.heal}/s\n`;
            msg += `  Vel ATK: ${tc.attackSpeed} ms\n\n`;

            msg += "‚õèÔ∏è Mina\n";
            msg += `  Custo:     ${m.cost} üí∞\n`;
            msg += `  Vida:      ${m.hp}/${m.maxHp}\n`;
            msg += `  Produz:    ${m.goldPerTick} üí∞ a cada ${m.tickInterval / 1000}s\n\n`;

            msg += "üè† Spawner de Arqueiras\n";
            msg += `  Custo:           ${towerDefs.tower_spawner.cost} üí∞\n`;
            msg += `  Vida:            ${towerDefs.tower_spawner.hp}/${towerDefs.tower_spawner.maxHp}\n`;
            msg += `  Gera 1 Arqueira a cada ${towerDefs.tower_spawner.spawnInterval / 1000}s\n\n`;

            msg += "üî• Torre Inferno\n";
            msg += `  Custo:   ${towerDefs.tower_inferno.cost} üí∞\n`;
            msg += `  Vida:    ${towerDefs.tower_inferno.hp}/${towerDefs.tower_inferno.maxHp}\n`;
            msg += `  Alcance: ${towerDefs.tower_inferno.range}\n`;
            msg += `  Dano:    10/40/90 por hit (5 hits/s, escala por tempo no mesmo alvo)\n\n`;


            alert(msg);
        }

        function buildTowerAtSlot(slotIndex, type) {
            const def = towerDefs[type];
            const slot = towerSlots[slotIndex];
            slot.occupied = {
                type,
                x: slot.x,
                y: slot.y,
                hp: def.hp,
                maxHp: def.maxHp,
                range: def.range,
                damage: def.damage,
                heal: def.heal,
                attackSpeed: def.attackSpeed,
                lastAttack: performance.now(),
                showRangeUntil: performance.now() + 10000,
                img: def.img,
                lastGoldTick: def.goldPerTick ? performance.now() : undefined,
                goldPerTick: def.goldPerTick,
                tickInterval: def.tickInterval,
                spawnInterval: def.spawnInterval,
                lastSpawn: 0,

                tornado: def.tornado, // ‚Üê ADICIONE ESTA LINHA!
            };
        }

        document.getElementById("btnAjuda").addEventListener("click", () => {
            alert(`‚ÑπÔ∏è Ajuda - Instru√ß√µes de Jogo:

üõ°Ô∏è Defenda seu castelo derrotando as ondas inimigas.
üí∞ Use moedas para comprar ou evoluir tropas.
‚öîÔ∏è Cada tropa tem um papel:
üß± TROPA BASE:
‚Ä¢ Espadachim: forte no corpo a corpo, r√°pido e √≥timo counter de Assassinos. Mas fraco contra Golem.
‚Ä¢ Arqueiro: dano √† dist√¢ncia. Baix√≠ssima vida ‚Äî sempre proteja com tanques!
‚Ä¢ Curador: regenera aliados, mas tem pouca vida.
‚Ä¢ Assassino: invis√≠vel e com muito dano inicial. Ideal contra tropas fr√°geis.
‚Ä¢ Golem: muita vida e bom dano, mas lento. Fraco contra magos e arqueiras.
‚Ä¢ Chefe: cria esqueletos e tem a maior vida do jogo.√© lento. Toma 2x dano de magos. N√£o pode ser evolu√≠do nem recebe upgrade.
‚Ä¢ Mago: anti-tank eficiente com dano em √°rea. Mas √© fr√°gil contra Assassinos, Espadachins e Arqueiros.
‚ú® EVOLU√á√ïES ESPECIAIS:
‚Ä¢ Arqueiro Evolu√≠do: os **3 primeiros tiros perfuram 2 inimigos por flecha**.
‚Ä¢ Curador Evolu√≠do: quando fica com <50% de HP, **se cura se n√£o estiver atacando ou apanhando**. Al√©m disso, **cura aliados pr√≥ximos enquanto anda**.
‚Ä¢ Assassino Evolu√≠do: se matar com hit-kill, **fica invis√≠vel novamente** e o pr√≥ximo ataque **ter√° dano m√°ximo**.
üéØ Dica: Evolua suas unidades para liberar poderes especiais!
Boa sorte na batalha!`);
        });

        function enemyBuildTower() {
            const tipos = ["tower_arqueira", "tower_curativa", "tower_inferno"];
            const freeSlots = [3, 4, 5].filter(i => !towerSlots[i].occupied);
            const tipo = tipos[Math.floor(Math.random() * tipos.length)];

            if (freeSlots.length > 0) {
                const idx = freeSlots[Math.floor(Math.random() * freeSlots.length)];
                buildTowerAtSlot(idx, tipo);
            } else {
                // cura 10% do HP m√°ximo do castelo inimigo
                const castle = castles.red;
                castle.hp = Math.min(castle.maxHp, castle.hp + castle.maxHp * 0.1);
            }
        }



        function spawnWave(count, side, waveNumber = 1) {
            const castle = side === "enemy" ? castles.red : castles.green;
            if (side === "enemy" && hardMode) {
                if (Math.random() < 0.5) enemyBuildTower();
            }

            // S√≥ permite chefe a partir da wave 2
            const types = Object
                .keys(troopDefs)
                .filter(k => k !== "esqueleto" && (waveNumber >= 2 || k !== "chefe"));

            // Contador de cada tipo na wave
            const typeCounts = {};

            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    let typeToSpawn;
                    // 80% de chance, s√≥ na √∫ltima tropa (i===count-1), s√≥ a partir da wave 2
                    if (
                        side === "enemy" &&
                        waveNumber >= 2 &&
                        i === count - 1 &&
                        Math.random() < 0.8
                    ) {
                        typeToSpawn = "chefe";
                    } else {
                        typeToSpawn = types[Math.floor(Math.random() * types.length)];
                    }

                    // Conta quantas desse tipo j√° spawnaram nesta wave
                    typeCounts[typeToSpawn] = (typeCounts[typeToSpawn] || 0) + 1;

                    // S√≥ pode evoluir se existir em evolution
                    const podeEvo = !!evolution[typeToSpawn];
                    const shouldEvo = side === "enemy" && hardMode && podeEvo && (typeCounts[typeToSpawn] % 3 === 0);

                    const def = troopDefs[typeToSpawn];
                    const arr = side === "enemy" ? enemies : allies;
                    const now = performance.now();

                    // Usa stats de EVO se for o caso, sen√£o stats normais
                    let stats = def;
                    if (shouldEvo) {
                        stats = { ...def, ...evolution[typeToSpawn].stats };
                    }

                    const t = {
                        type: typeToSpawn,
                        x: castle.x,
                        y: castle.y,
                        hp: stats.maxHp,
                        maxHp: stats.maxHp,
                        damage: stats.damage,
                        range: stats.range,
                        speed: stats.speed,
                        attackSpeed: stats.attackSpeed,
                        lastAttack: now,
                        _angle: 0,
                        isEvo: !!shouldEvo,
                        ...(typeToSpawn === "chefe" && {
                            lastSkeleton: now,
                            skeletonCount: 0,
                            triggers: { 80: false, 60: false, 40: false, 20: false }
                        })
                    };
                    t.id = nextTroopId++;

                    // Ajustes especiais para assassino
                    if (typeToSpawn === "assassino") {
                        t.invisible = true;
                        t.firstHit = true;
                        if (shouldEvo) {
                            t.firstHitDamage = evolution.assassino.stats.firstHitDamage;
                        } else {
                            t.invisibleUntil = now + 15000;
                        }
                    }

                    arr.push(t);
                }, (i / count) * waveDuration);
            }
        }

        function spawnEnemyInstant(type, options = {}) {
            const def = troopDefs[type];
            const now = performance.now();
            const t = {
                type,
                x: castles.red.x,
                y: castles.red.y,
                hp: options.evolved ? evolution[type].stats.hp : def.maxHp,
                maxHp: options.evolved ? evolution[type].stats.maxHp : def.maxHp,
                damage: options.evolved && evolution[type].stats.damage !== undefined
                    ? evolution[type].stats.damage : def.damage,
                range: options.evolved && evolution[type].stats.range !== undefined
                    ? evolution[type].stats.range : def.range,
                speed: options.evolved && evolution[type].stats.speed !== undefined
                    ? evolution[type].stats.speed : def.speed,
                attackSpeed: options.evolved && evolution[type].stats.attackSpeed !== undefined
                    ? evolution[type].stats.attackSpeed : def.attackSpeed, // <-- ADICIONE ESTA LINHA
                lastAttack: now,
                _angle: 0,
                isEvo: !!options.evolved
            };
            enemies.push(t);
        }
        let gameEnded = false;

        function checkEndConditions() {
            if (gameEnded) return; // impede m√∫ltiplos alerts

            if (castles.red.hp <= 0) {
                gameEnded = true;
                alert("üèÜ Voc√™ venceu!");
                sessionStorage.setItem("victory", "true");
                // l√™ a dificuldade e aplica a recompensa
                const diff = sessionStorage.getItem("battleDiff");
                if (diff === "easy") {
                    // +3 cocos gr√°tis
                    const prev = Number(sessionStorage.getItem("rewardCocos") || 0);
                    sessionStorage.setItem("rewardCocos", prev + 3);
                }
                else if (diff === "medium") {
                    // +1 Po√ß√£o de Zoom gr√°tis
                    sessionStorage.setItem("rewardZoomPotion", 1);
                }
                else if (diff === "hard" || diff === "insane") {
                    // +1 Po√ß√£o de Buff gr√°tis
                    sessionStorage.setItem("rewardBuffPotion", 1);

                    // Se for exatamente ‚Äúinsane‚Äù, d√° um ba√∫ extra
                    if (diff === "insane") {
                        // marca que tem direito a 1 ba√∫ gr√°tis
                        sessionStorage.setItem("rewardChest", 1);
                    }
                }

                // <--- ADICIONE ESTA LINHA
                resetGame();
            }
            if (castles.green.hp <= 0) {
                gameEnded = true;
                alert("üíÄ Voc√™ perdeu!");
                resetGame();
            }
        }

        function resetGame() {
            // por exemplo, recarregar a p√°gina:
            window.location.reload();
        }

        let scale = 1;
        const minScale = 0.5,
            maxScale = 2;

        // roda do mouse
        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            scale += -e.deltaY * 0.001;
            scale = Math.min(maxScale, Math.max(minScale, scale));
            draw();
        });

        // bot√µes + / ‚Äì
        const zoomContainer = document.createElement("div");
        zoomContainer.id = "zoomContainer";
        zoomContainer.innerHTML = `
  <button id="zoomIn">+</button>
  <button id="zoomOut">‚àí</button>
`;
        document.body.appendChild(zoomContainer);
        document.getElementById("zoomIn").onclick = () => {
            scale = Math.min(maxScale, scale + 0.1);
            draw();
        };
        document.getElementById("zoomOut").onclick = () => {
            scale = Math.max(minScale, scale - 0.1);
            draw();
        };


        // ======= Eventos de arraste para mover a c√¢mera =======
        canvas.addEventListener("mousedown", (e) => {
            camera.dragging = true;
            camera.lastX = e.clientX;
            camera.lastY = e.clientY;
            canvas.style.cursor = "grabbing";
        });
        window.addEventListener("mousemove", (e) => {
            if (!camera.dragging) return;
            const dx = e.clientX - camera.lastX;
            const dy = e.clientY - camera.lastY;
            camera.x -= dx;
            camera.y -= dy;
            camera.lastX = e.clientX;
            camera.lastY = e.clientY;
            clampCamera();
            draw();
        });
        window.addEventListener("mouseup", () => {
            camera.dragging = false;
            canvas.style.cursor = "grab";
        });

        // Toques (mobile)
        canvas.addEventListener("touchstart", (e) => {
            camera.dragging = true;
            camera.lastX = e.touches[0].clientX;
            camera.lastY = e.touches[0].clientY;
        });
        window.addEventListener("touchmove", (e) => {
            if (!camera.dragging) return;
            const t = e.touches[0];
            const dx = t.clientX - camera.lastX;
            const dy = t.clientY - camera.lastY;
            camera.x -= dx;
            camera.y -= dy;
            camera.lastX = t.clientX;
            camera.lastY = t.clientY;
            clampCamera();
            draw();
        });
        window.addEventListener("touchend", () => {
            camera.dragging = false;
        });

        function renderShop() {
            const container = document.getElementById("upgrades");
            container.innerHTML = "";

            Object.entries(upgrades).forEach(([type, stats]) => {
                // s√≥ mostra se existe troopDefs[type]
                const div = document.createElement("div");
                div.innerHTML = `<strong>${troopDefs[type].name}</strong><br>`;
                // para cada stat poss√≠vel
                Object.keys(stats).forEach((stat) => {
                    // melee n√£o tem range
                    if (stat === "range" && troopDefs[type].range <= 50) return;
                    const lvl = stats[stat];
                    const maxLvl = (stat === "range") ? 3 : 5;
                    const disabled = lvl >= maxLvl ? "disabled" : "";
                    div.innerHTML += `
        <button data-type="${type}" data-stat="${stat}"
                ${disabled}>
          ${stat.toUpperCase()}: ${lvl}/${maxLvl}
        </button>
      `;
                });
                // evolu√ß√£o
                if (evolution[type]) {
                    const evo = evolution[type];
                    const btnE = evo.unlocked ?
                        `<span>Evolu√ß√£o desbloqueada</span>` :
                        `<button data-evo="${type}">
           Evoluir (${evo.cost}üí∞)
         </button>`;
                    div.innerHTML += `<div>${btnE}</div>`;
                }
                container.appendChild(div);
            });
        }

        // Listener para os bot√µes de upgrade / evolu√ß√£o na loja
        document.getElementById("upgrades").addEventListener("click", (e) => {
            const btn = e.target;

            // 1) Upgrade de stat (100 üí∞)
            if (btn.dataset.type && btn.dataset.stat) {
                const type = btn.dataset.type;
                const stat = btn.dataset.stat;
                const maxLvl = stat === "range" ? 3 : 5;

                if (money < 100) {
                    return alert("Voc√™ n√£o tem moedas suficientes para esse upgrade!");
                }
                if (upgrades[type][stat] >= maxLvl) {
                    return alert(`${stat.toUpperCase()} j√° est√° no n√≠vel m√°ximo!`);
                }

                // aplica o upgrade
                money -= 100;
                upgrades[type][stat]++;
                renderShop();
                return;
            }

            // 2) Compra de evolu√ß√£o
            if (btn.dataset.evo) {
                const type = btn.dataset.evo;
                const evo = evolution[type];
                if (evo.unlocked) return;
                if (money < evo.cost) return alert("üí∞ Insuficiente para evoluir!");

                money -= evo.cost;
                evo.unlocked = true;
                localStorage.setItem(`evo_${type}`, true);
                renderShop();
                return;
            }
        });


        function clampCamera() {
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;

            const maxX = Math.min(WORLD_SIZE, castles.green.x + 100); // 100px al√©m do castelo verde
            camera.x = Math.max(0, Math.min(maxX - viewWidth, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_SIZE - viewHeight, camera.y));
        }

        // ======= Fun√ß√£o de desenho =======
        function draw() {

            ctx.save();
            ctx.scale(scale, scale);
            // Limpa a tela
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Desenha o ch√£o (ilha marrom)
            ctx.fillStyle = "#8B4513"; // marrom
            ctx.fillRect(-camera.x, -camera.y, WORLD_SIZE, WORLD_SIZE);

            // Desenha castelos com c√≠rculo
            for (const [key, c] of Object.entries(castles)) {
                if (!c.img) continue;
                const screenX = c.x - camera.x;
                const screenY = c.y - camera.y;
                // c√≠rculo
                ctx.beginPath();
                ctx.arc(screenX, screenY, 70, 0, Math.PI * 2);
                ctx.fillStyle =
                    key === "green" ? "rgba(0,255,0,0.3)" : "rgba(255,0,0,0.3)";
                ctx.fill();
                // imagem centralizada
                ctx.drawImage(c.img, screenX - 64, screenY - 64, 128, 128);
            }
            // desenha os 6 slots como linhas semi-transparentes
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            towerSlots.forEach(slot => {
                const sx = slot.x - camera.x;
                const sy = slot.y - camera.y;
                ctx.strokeRect(sx - slot.w / 2, sy - slot.h / 2, slot.w, slot.h);
            });
            ctx.restore();

            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî RENDER de cada torre ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            towerSlots.forEach((slot, i) => {
                const tw = slot.occupied;
                if (!tw || tw.hp <= 0) return;

                const sx = slot.x - camera.x;
                const sy = slot.y - camera.y;

                // Alcance
                if (tw.showRangeUntil && performance.now() < tw.showRangeUntil) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(sx, sy, tw.range, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(0,255,0,0.3)";
                    ctx.fill();
                    ctx.restore();
                } else {
                    delete tw.showRangeUntil;
                }

                // Imagem
                if (tw.img && tw.img.complete) {
                    ctx.drawImage(tw.img, sx - 25, sy - 25, 50, 50);
                } else {
                    ctx.fillStyle = "#888";
                    ctx.fillRect(sx - 25, sy - 25, 50, 50);
                }

                // Barra de vida
                const pct = tw.hp / tw.maxHp;
                ctx.fillStyle = "gray";
                ctx.fillRect(sx - 20, sy - 35, 40, 6);
                // torres do inimigo (slots 3,4,5) ficam vermelhas, jogador verde
                ctx.fillStyle = (i >= 3 ? "red" : "green");
                ctx.fillRect(sx - 20, sy - 35, 40 * pct, 6);
            });

            activeBombs.forEach(b => {
                const pu = powerUpDefs.bomba;
                const bx = b.x - camera.x - 15;
                const by = b.y - camera.y - 15;
                if (imgBombaLoaded) {
                    ctx.drawImage(imgBomba, bx, by, 30, 30);
                } else {
                    ctx.save();
                    ctx.fillStyle = "#888";
                    ctx.beginPath();
                    ctx.arc(b.x - camera.x, b.y - camera.y, 15, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
                // c√≠rculo de range
                ctx.save();
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(b.x - camera.x, b.y - camera.y, pu.range, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            });

            activeFreezes.forEach(fz => {
                const pu = powerUpDefs.congelar;
                if (imgCongelarLoaded) {
                    ctx.drawImage(imgCongelar, fz.x - camera.x - 24, fz.y - camera.y - 24, 48, 48);
                }
                ctx.save();
                ctx.strokeStyle = pu.effectColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(fz.x - camera.x, fz.y - camera.y, pu.range, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            });

            activeHeals.forEach(h => {
                const pu = powerUpDefs.cura;
                if (imgCuraLoaded) {
                    ctx.drawImage(imgCura, h.x - camera.x - 24, h.y - camera.y - 24, 48, 48);
                }
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(h.x - camera.x, h.y - camera.y, pu.range, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            });

            projectiles.forEach(p => {
                const sx = p.x - camera.x;
                const sy = p.y - camera.y;
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(p.angle);

                if (p.type === "tornado") {
                    if (imgTornadoLoaded) {
                        ctx.drawImage(imgTornado, -32, -32, 64, 64);
                    } else {
                        ctx.save();
                        ctx.fillStyle = "rgba(200,200,255,0.5)";
                        ctx.beginPath();
                        ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.restore();
                    return;
                }

                if (!p.slowFactor) {
                    // proj√©til da arqueira
                    ctx.drawImage(arrowImg, -18, -6, 36, 12);
                } else {
                    // proj√©til do mago
                    if (mageBallImg && mageBallImg.complete) {
                        ctx.drawImage(mageBallImg, -16, -16, 32, 32);
                    } else {
                        // fallback: esfera azul sem imagem
                        ctx.beginPath();
                        ctx.arc(0, 0, 16, 0, 2 * Math.PI);
                        ctx.fillStyle = "#00bfff";
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }

                ctx.restore();
            });


            allies.forEach((t) => drawTroop(t, "ally"));
            enemies.forEach((t) => drawTroop(t, "enemy"));

            ctx.restore(); // restaura o zoom original antes do HUD

            // TODO: desenhar tropas, ondas, interface de moedas etc.
            // Desenha tropas aliadas
            // HUD do dinheiro
            ctx.fillStyle = "white";
            ctx.font = "20px sans-serif";
            ctx.fillText(`Dinheiro: ${money} üí∞`, 10, 30);

            drawElixir(ctx);

            // Barras de vida dos castelos (topo da tela)
            const barW = 200;
            const pctG = castles.green.hp / castles.green.maxHp;
            const pctR = castles.red.hp / castles.red.maxHp;

            ctx.fillStyle = "gray";
            ctx.fillRect(20, 50, barW, 12);
            ctx.fillRect(20, 70, barW, 12);

            ctx.fillStyle = "green";
            ctx.fillRect(20, 50, barW * pctG, 12);
            ctx.fillStyle = "red";
            ctx.fillRect(20, 70, barW * pctR, 12);

            // dentro de draw(), no final:
            drawCastleIndicator();
        }

        function drawCastleIndicator() {
            // posi√ß√£o na tela (ap√≥s scale e camera)
            const screenX = (castles.green.x - camera.x) * scale;
            const screenY = (castles.green.y - camera.y) * scale;
            // se o castelo estiver dentro da √°rea vis√≠vel, n√£o desenha o indicador
            if (
                screenX >= 0 &&
                screenX <= canvas.width &&
                screenY >= 0 &&
                screenY <= canvas.height
            ) {
                return;
            }
            // ajusta para ficar sempre dentro da tela (margem de 12.5px)
            const dotX = Math.min(Math.max(screenX, 12.5), canvas.width - 12.5);
            const dotY = Math.min(Math.max(screenY, 12.5), canvas.height - 12.5);

            ctx.fillStyle = "green";
            ctx.beginPath();
            ctx.arc(dotX, dotY, 12.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawElixir(ctx) {
            ctx.font = "20px sans-serif";
            ctx.fillStyle = "aqua";
            ctx.fillText("Elixir: " + elixir, canvas.width - 150, 30);
        }


        function drawCastle(c, color) {
            const screenX = c.x - camera.x;
            const screenY = c.y - camera.y;

            // c√≠rculo de contorno
            ctx.beginPath();
            ctx.arc(screenX, screenY, 70, 0, Math.PI * 2);
            ctx.fillStyle =
                ctx.fillRect(screenX - 60, screenY - 80, 120, 8);
            ctx.fillStyle = color;
            ctx.fillRect(screenX - 60, screenY - 80, barW, 8);

            // imagem
            if (c.img) {
                ctx.drawImage(c.img, screenX - 64, screenY - 64, 128, 128);
            }
        }

        // Bombas ativas
        const activeBombs = [];
        function spawnBomb(x, y, startTime) {
            activeBombs.push({ x, y, startTime });
        }
        function updateBombs(ts, ctx) {
            const pu = powerUpDefs.bomba;
            for (let i = activeBombs.length - 1; i >= 0; i--) {
                const b = activeBombs[i];
                const elapsed = ts - b.startTime;

                // Removido: desenho da bomba e do c√≠rculo de range

                if (elapsed >= pu.delay) {
                    // Dano em tropas inimigas
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const u = enemies[j];
                        const dx = u.x - b.x;
                        const dy = u.y - b.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist <= pu.range) {
                            applyDamage(u, pu.damage);
                        }
                    }
                    // Dano em torres inimigas (slots 3,4,5)
                    [3, 4, 5].forEach(idx => {
                        const slot = towerSlots[idx];
                        if (slot.occupied && slot.occupied.hp > 0) {
                            const tw = slot.occupied;
                            const dx = tw.x - b.x;
                            const dy = tw.y - b.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist <= pu.range) {
                                applyDamage(tw, pu.damage / pu.towerDmgDiv);
                            }
                        }
                    });
                    // Remove a bomba ap√≥s explodir
                    activeBombs.splice(i, 1);
                }
            }
        }


        // Zonas de cura ativas
        const activeHeals = [];
        function spawnHealZone(x, y, startTime) {
            activeHeals.push({ x, y, startTime, lastHealSec: 0 });
        }
        function updateHeals(ts, ctx) {
            const pu = powerUpDefs.cura;
            for (let i = activeHeals.length - 1; i >= 0; i--) {
                const h = activeHeals[i];
                const elapsed = ts - h.startTime;

                if (elapsed < pu.duration) {
                    // 2) Calcular quantos segundos se passaram desde o √∫ltimo heal
                    const healedSecs = Math.floor(elapsed / 1000);
                    const deltaSecs = healedSecs - (h.lastHealSec || 0);
                    if (deltaSecs > 0) {
                        h.lastHealSec = healedSecs;
                        // 3) Aplicar cura a cada tropa aliada dentro do range
                        allies.forEach(u => {
                            const dx = u.x - h.x;
                            const dy = u.y - h.y;
                            if (Math.hypot(dx, dy) <= pu.range) {
                                u.hp = Math.min(u.maxHp, u.hp + pu.healPerSec * deltaSecs);
                            }
                        });

                        towerSlots.slice(0, 3).forEach(slot => {
                            if (slot.occupied && slot.occupied.hp > 0) {
                                const dx = slot.x - h.x;
                                const dy = slot.y - h.y;
                                if (Math.hypot(dx, dy) <= pu.range) {
                                    slot.occupied.hp = Math.min(slot.occupied.maxHp, slot.occupied.hp + pu.healPerSec * deltaSecs);
                                }
                            }
                        });
                    }
                } else {
                    // expirada: remover zona de cura
                    activeHeals.splice(i, 1);
                }
            }
        }

        function spawnSkeletons(boss, count) {
            // Decide o lado: se o boss est√° em allies, vai para allies; se est√° em enemies, vai para enemies
            const arr = allies.includes(boss) ? allies : enemies;
            for (let i = 0; i < count; i++) {
                const def = troopDefs.esqueleto;
                const side = (i % 2 === 0) ? -1 : +1;
                const idx = Math.floor(i / 2);
                const offsetX = side * (20 + idx * 10);
                const sk = {
                    type: "esqueleto",
                    x: boss.x + offsetX,
                    y: boss.y,
                    hp: def.maxHp,
                    maxHp: def.maxHp,
                    damage: def.damage,
                    range: def.range,
                    speed: def.speed,
                    attackSpeed: def.attackSpeed, // <-- ADICIONE ESTA LINHA
                    lastAttack: performance.now(),
                    id: nextTroopId++ // <-- ADICIONE ESTA LINHA
                };
                arr.push(sk); // agora vai para o lado certo!
            }
        }

        function trySpawnBossSkeletons(boss, ts) {
            if (boss.hp <= 0) return;

            // üîí seguran√ßa: garante que todos os campos de spawn estejam presentes
            if (!boss.triggers) {
                boss.triggers = { 80: false, 60: false, 40: false, 20: false };
            }
            if (boss.lastSkeleton === undefined) boss.lastSkeleton = ts;
            if (boss.skeletonCount === undefined) boss.skeletonCount = 0;

            // spawn autom√°tico
            if (ts - boss.lastSkeleton >= 12000 && boss.skeletonCount + 2 <= 26) {
                spawnSkeletons(boss, 2);
                boss.lastSkeleton = ts;
                boss.skeletonCount += 2;
            }

            // thresholds
            const pct = boss.hp / boss.maxHp * 100;
            [80, 60, 40, 20].forEach(th => {
                if (pct <= th && !boss.triggers[th]) {
                    const qtd = (th === 80 || th === 20) ? 4 : 2;
                    spawnSkeletons(boss, qtd);
                    boss.skeletonCount += qtd; // <-- Adicione esta linha!
                    boss.triggers[th] = true;
                }
            });
        }

        function assassinoAttackLogic(t, target, ts) {
            // escolhe o dano deste ataque
            const dmg = t.firstHit
                ? (t.isEvo ? t.firstHitDamage : 450)
                : t.damage;

            // aplica dano e guarda se matou
            const killed = applyDamage(target, dmg);
            if (t.firstHit) {
                // flagged: primeiro golpe remove invisibilidade
                t.firstHit = false;
                t.invisible = false;

                if (t.isEvo) {
                    // se for evolu√≠do e matou, agenda re-invisibilidade
                    if (killed) {
                        t.rehideTime = ts + 2000;
                    } else {
                        // se n√£o matou, perde pra sempre
                        delete t.rehideTime;
                    }
                }
            }
            else if (t.isEvo && t.rehideTime) {
                // j√° usou o firstHit evolu√≠do e marcou rehideTime
                // se atacar outra tropa antes do tempo, cancela o rehide
                if (ts < t.rehideTime) {
                    delete t.rehideTime;
                }
            }

            return killed;
        }

        function update(ts, ctx) {
            [...allies, ...enemies].forEach((t) => {
                if (t.type === "assassino" && t.invisible) {
                    // s√≥ vence por tempo se ainda N√ÉO atacou
                    if (t.firstHit && ts >= t.invisibleUntil) {
                        t.invisible = false;
                        t.firstHit = true;        // garante que n√£o volte
                    }
                }

                // ...existing code...
                if (t.frozenUntil && ts < t.frozenUntil) {
                    t._canAttack = false;
                } else {
                    t._canAttack = true;
                }
                // Se o efeito de slow expirou, restaura a velocidade original
                if (t.slowExpires && ts >= t.slowExpires) {
                    t.speed = troopDefs[t.type].speed;
                    delete t.originalSpeed;
                    delete t.slowExpires;
                }
            });

            allies.forEach(t => {
                if (
                    t.type === "assassino" &&
                    t.isEvo &&
                    t.rehideTime &&
                    ts >= t.rehideTime
                ) {
                    t.invisible = true;
                    t.firstHit = true;
                    delete t.rehideTime;
                }
            });

            console.log("update, money =", money);
            const dt = (ts - lastTime) / 1000;

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ AUTOCURA E AURA DE CURA DA CURADORA EVOLU√çDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            allies.forEach(u => {
                if (u.type === "curador" && u.isEvo) {
                    const now = ts;
                    const dtSec = dt; // j√° em segundos

                    // Detecta se est√° andando (posi√ß√£o mudou)
                    if (u.lastX === undefined) u.lastX = u.x;
                    if (u.lastY === undefined) u.lastY = u.y;
                    const isMoving = (u.x !== u.lastX || u.y !== u.lastY);

                    const hpPct = u.hp / u.maxHp;
                    const timeSinceHit = now - (u.lastAttackedAt || 0);

                    // 1) Autocura: 250 HP/s se ‚â§50% HP, sem hits h√° 3s e movendo
                    if (hpPct <= 0.5 && timeSinceHit >= 3000 && isMoving) {
                        u.hp = Math.min(u.maxHp, u.hp + 250 * dtSec);
                    }

                    // 2) Cura em √°rea: 100 HP/s a aliados em at√© 100px enquanto anda
                    if (isMoving) {
                        allies.forEach(ally => {
                            if (ally !== u) {
                                const dx = ally.x - u.x, dy = ally.y - u.y;
                                if (Math.hypot(dx, dy) <= 100) {
                                    ally.hp = Math.min(ally.maxHp, ally.hp + 100 * dtSec);
                                }
                            }
                        });
                    }

                    // Atualiza posi√ß√£o para o pr√≥ximo frame
                    u.lastX = u.x;
                    u.lastY = u.y;
                }
            });

            // Regenera√ß√£o do castelo vermelho em hard mode
            if (hardMode) {
                const since = ts - castles.red.lastHitTime;
                if (since >= 20000 && castles.red.hp > 0 && castles.red.hp < castles.red.maxHp) {
                    // dt em segundos
                    castles.red.hp = Math.min(
                        castles.red.maxHp,
                        castles.red.hp + 10 * dt
                    );
                }
            }
            lastTime = ts;

            // dentro de update(ts), ap√≥s regenera√ß√£o do red castle:
            checkHardModeTriggers();

            updateFreezes(ts);

            updateBombs(ts, ctx);

            updateHeals(ts, ctx);

            enemies.forEach(u => {
                if (u.type === "chefe") {
                    trySpawnBossSkeletons(u, ts);
                }
            });

            allies.forEach(u => {
                if (u.type === "chefe") {
                    trySpawnBossSkeletons(u, ts);
                }
            });

            // para cada torre constru√≠da
            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî ATUALIZA√á√ÉO de cada torre ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            towerSlots.forEach((slot, i) => {
                const tw = slot.occupied;
                if (!tw) return;
                if (tw._canAttack === false) return; // ‚Üê impede atacar se congelado

                if (tw.frozenUntil && ts < tw.frozenUntil) {
                    tw._canAttack = false;
                } else {
                    tw._canAttack = true;
                }

                if (tw.type === "mine") {
                    if (ts - tw.lastGoldTick >= tw.tickInterval) {
                        money += tw.goldPerTick;
                        tw.lastGoldTick = ts;
                    }
                    return; // mina n√£o faz mais nada (n√£o ataca/√© curada)
                }

                if (tw.type === "tower_spawner") {
                    if (ts - tw.lastSpawn >= tw.spawnInterval) {
                        tw.lastSpawn = ts;
                        const def = troopDefs.arqueiro;
                        const nova = {
                            type: "arqueiro",
                            x: tw.x,
                            y: tw.y,
                            hp: def.maxHp,
                            maxHp: def.maxHp,
                            damage: def.damage,
                            range: def.range,
                            speed: def.speed,
                            attackSpeed: def.attackSpeed,
                            lastAttack: ts,
                            _angle: 0
                            id: nextTroopId++
                        };
                        // se for slot inimigo (√≠ndices 3,4,5), √© inimigo; sen√£o, aliado
                        if (i >= 3) enemies.push(nova);
                        else allies.push(nova);
                    }
                    return;
                }

                // 1.1) Ataque / Cura
                if (tw.hp > 0 && ts - tw.lastAttack >= tw.attackSpeed) {
                    if (tw.type === "tower_vento") {
                        tw.lastAttack = ts;
                        const dx = (i < 3 ? -tw.tornado.speed : tw.tornado.speed);
                        projectiles.push({
                            type: "tornado",
                            x: tw.x,
                            y: tw.y,
                            dx: dx,
                            dy: 0,
                            spawnTime: ts
                        });
                        return;  // interrompe o fluxo para n√£o cair nos outros ataques
                    }

                    if (tw.type === "tower_curativa") {
                        if (ts - tw.lastAttack >= tw.attackSpeed) {
                            // define alvos conforme o lado da torre (i < 3 = jogador; i >= 3 = inimigo)
                            const healTargets = (i >= 3 ? enemies : allies);
                            const attackTargets = (i >= 3 ? allies : enemies);

                            // 1) cura suas pr√≥prias tropas
                            healTargets.forEach(unit => {
                                const d = Math.hypot(unit.x - tw.x, unit.y - tw.y);
                                if (d <= tw.range) {
                                    unit.hp = Math.min(unit.maxHp, unit.hp + tw.heal);
                                }
                            });

                            // 2) encontra e ataca tropas do oponente
                            let curTarget = null, curMinD = Infinity;
                            attackTargets.forEach(unit => {
                                const d = Math.hypot(unit.x - tw.x, unit.y - tw.y);
                                if (d < curMinD) {
                                    curMinD = d;
                                    curTarget = unit;
                                }
                            });
                            if (curTarget && curMinD <= tw.range) {
                                const killed = applyDamage(curTarget, tw.damage);
                                if (killed) money += rewardForKill[curTarget.type] || 0;
                            }

                            // 3) atualiza cooldown
                            tw.lastAttack = ts;
                        }
                        return;
                    }

                    else if (tw.type === "tower_arqueira") {
                        // define targets conforme o lado da torre
                        const attackTargets = (i >= 3 ? allies : enemies);

                        let target = null, minD = Infinity;
                        attackTargets.forEach(u => {
                            const d = Math.hypot(u.x - tw.x, u.y - tw.y);
                            if (d < minD) {
                                minD = d;
                                target = u;
                            }
                        });
                        if (target && minD <= tw.range) {
                            const killed = applyDamage(target, tw.damage);
                            if (killed) money += rewardForKill[target.type] || 0;
                        }
                        tw.lastAttack = ts;
                    }

                    else if (tw.type === "tower_inferno") {
                        if (!tw.inferno) {
                            tw.inferno = {
                                stage: 1,
                                target: null,
                                stageStart: 0
                            };
                        }
                        const attackTargets = (i >= 3 ? allies : enemies);

                        // Se n√£o tem alvo ou alvo morreu ou saiu do alcance, procura novo alvo (maior HP dentro do alcance)
                        let needNewTarget = false;
                        if (
                            !tw.inferno.target ||
                            tw.inferno.target.hp <= 0 ||
                            Math.hypot(tw.inferno.target.x - tw.x, tw.inferno.target.y - tw.y) > tw.range
                        ) {
                            needNewTarget = true;
                        }

                        if (needNewTarget) {
                            let target = null, maxHp = -1;
                            attackTargets.forEach(u => {
                                if (u.type === "assassino" && u.invisible) return;
                                const d = Math.hypot(u.x - tw.x, u.y - tw.y);
                                if (d <= tw.range && u.hp > maxHp) {
                                    maxHp = u.hp;
                                    target = u;
                                }
                            });
                            tw.inferno.target = target;
                            tw.inferno.stage = 1;
                            tw.inferno.stageStart = performance.now();
                        }

                        const target = tw.inferno.target;
                        if (!target) {
                            tw.inferno.stage = 1;
                            tw.inferno.stageStart = 0;
                            tw.lastAttack = ts;
                            return;
                        }

                        // Est√°gio 1 dura 3s, os outros 5s
                        const now = performance.now();
                        if (tw.inferno.stage === 1 && now - tw.inferno.stageStart >= 3000) {
                            tw.inferno.stage = 2;
                            tw.inferno.stageStart = now;
                        } else if (tw.inferno.stage === 2 && now - tw.inferno.stageStart >= 5000) {
                            tw.inferno.stage = 3;
                            tw.inferno.stageStart = now;
                        }

                        let dmg = 10;
                        if (tw.inferno.stage === 2) dmg = 40;
                        else if (tw.inferno.stage === 3) dmg = 90;

                        while (ts - tw.lastAttack >= tw.attackSpeed) {
                            const killed = applyDamage(target, dmg);
                            tw.lastAttack += tw.attackSpeed;
                            if (killed) {
                                tw.inferno.target = null;
                                tw.inferno.stage = 1;
                                tw.inferno.stageStart = 0;
                                money += rewardForKill[target.type] || 0;
                                break;
                            }
                        }
                        return;
                    }
                }




                // 1.2) Explos√£o da torre curativa ao morrer
                if (tw.hp <= 0) {
                    if (tw.type === "tower_curativa") {
                        const R = 550;

                        // define os alvos corretos com base no dono da torre
                        const healTargets = (i >= 3 ? enemies : allies);
                        const attackTargets = (i >= 3 ? allies : enemies);

                        // Cura aliados pr√≥ximos
                        healTargets.forEach(unit => {
                            if (Math.hypot(unit.x - tw.x, unit.y - tw.y) <= R) {
                                unit.hp = Math.min(unit.maxHp, unit.hp + 1500);
                            }
                        });

                        // Dano em inimigos pr√≥ximos
                        attackTargets.forEach(unit => {
                            if (Math.hypot(unit.x - tw.x, unit.y - tw.y) <= R) {
                                applyDamage(unit, 350);
                            }
                        });
                    }

                    // ‚îÄ‚îÄ Novo: tornado final da Torre de Vento ‚îÄ‚îÄ
                    if (tw.type === "tower_vento") {
                        const now = performance.now();
                        // slots 0,1,2 = jogador (esquerda), 3,4,5 = inimigo (direita)
                        const dx = (i < 3 ? -tw.tornado.speed : tw.tornado.speed);
                        projectiles.push({
                            type: "tornado",
                            x: slot.x,
                            y: slot.y,
                            dx: dx,
                            dy: 0,
                            spawnTime: now
                        });
                    }
                    // remove a torre
                    slot.occupied = null;
                }

            });


            // Dentro de update(ts), antes de moveTroops / proj√©teis:
            towerSlots.forEach((slot, i) => {
                const tw = slot.occupied;
                if (tw && tw.hp <= 0) {
                    // 1) Se for torre *inimiga* (√≠ndices 3,4,5):
                    if (i >= 3) {
                        money += rewardForKill[tw.type] || 0; // agora pega o valor correto!
                    }
                    // 2) Libera o slot
                    slot.occupied = null;
                }
            });


            function moveTroops(list, opponents, castleTarget) {
                const isEnemy = list === enemies;

                list.forEach((t) => {
                    const def = troopDefs[t.type];
                    const damage = t.damage !== undefined ? t.damage : def.damage;
                    // 1) busca tropa inimiga mais pr√≥xima:
                    let target = null;
                    let minD = Infinity;

                    if (t._canAttack === false) return; // ‚Üê impede atacar se congelado

                    opponents.forEach((o) => {
                        if (o.type === "assassino" && o.invisible) return; // <-- AQUI
                        const dx = o.x - t.x,
                            dy = o.y - t.y;
                        const d = Math.hypot(dx, dy);
                        if (d < minD) {
                            minD = d;
                            target = o;
                        }
                    });
                    // 2) se n√£o achou tropa, mira no castelo:
                    if (!target) {
                        const c = castleTarget;
                        const dx = c.x - t.x,
                            dy = c.y - t.y;
                        minD = Math.hypot(dx, dy);
                        target = c;
                    }

                    // 3) se estiver fora do alcance, anda em dire√ß√£o:
                    if (minD > t.range) {
                        const vx = (target.x - t.x) / minD;
                        const vy = (target.y - t.y) / minD;
                        const speed = t.speed !== undefined ? t.speed : def.speed;
                        t.x += vx * speed * dt;
                        t.y += vy * speed * dt;
                        t._angle = Math.atan2(target.y - t.y, target.x - t.x); // guarda √¢ngulo para render
                    } else {
                        // Arqueiro dispara flecha
                        if (
                            t.type === "arqueiro" &&
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            t._angle = Math.atan2(target.y - t.y, target.x - t.x);
                            const vx = Math.cos(t._angle);
                            const vy = Math.sin(t._angle);
                            if (t.isEvo) {
                                t.shotsFired = (t.shotsFired || 0) + 1;
                            }
                            // Nos 3 primeiros tiros, penetra 2 alvos; depois, penetra s√≥ 1 (comportamento normal)
                            const pierce = (t.isEvo && t.shotsFired <= 3) ? 2 : 1;
                            projectiles.push({
                                x: t.x + vx * 20,
                                y: t.y + vy * 20,
                                vx: vx * 400,
                                vy: vy * 400,
                                angle: t._angle,
                                damage: t.damage,
                                side: list === allies ? "ally" : "enemy",
                                pierce,         // quantos alvos pode perfurar
                                pierced: 0,      // contagem de alvos j√° perfurados
                                hitTargets: [], // ‚Üê novo campo
                            });
                            t.lastAttack = ts;
                        }

                        // Mago lan√ßa ataque m√°gico (parecido com flecha, mas com lentid√£o)
                        else if (t.type === "mago" && ts - t.lastAttack >= t.attackSpeed) {
                            t._angle = Math.atan2(target.y - t.y, target.x - t.x);
                            const vx = Math.cos(t._angle);
                            const vy = Math.sin(t._angle);
                            projectiles.push({
                                x: t.x + vx * 20,
                                y: t.y + vy * 20,
                                vx: vx * 350,
                                vy: vy * 350,
                                angle: t._angle,
                                damage: t.damage,
                                slowFactor: 0.5, // aplica lentid√£o
                                slowDuration: 3000, // 3 segundos em ms
                                side: list === allies ? "ally" : "enemy",
                                pierce: 1,      // ‚Üê ADICIONE ESTA LINHA
                                pierced: 0,
                                hitTargets: [], // ‚Üê novo campo
                            });
                            t.lastAttack = ts;
                        }

                        // Espadachim: ataque corpo-a-corpo direto
                        else if (
                            t.type === "espadachim" &&
                            minD <= t.range &&              // <-- aqui
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            const killed = applyDamage(
                                target,
                                t.damage * (t.attackSpeed / 1000)
                            );
                            t.lastAttack = ts;

                            // Se matou tropa inimiga, d√° a recompensa certa
                            if (killed && list === allies && target !== castleTarget) {
                                money += rewardForKill[target.type] || 0;
                            }

                            // Se foi hit no castelo, ganha 10 üí∞
                            if (target === castleTarget) {
                                money += 10;
                                castleTarget.lastHitTime = ts;
                                checkEndConditions();
                            }
                        }

                        // Curador: cura aliados pr√≥ximos
                        else if (
                            t.type === "curador" &&
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            let healed = false;
                            list.forEach((ally) => {
                                if (ally !== t && ally.hp < ally.maxHp) {
                                    const dx = ally.x - t.x;
                                    const dy = ally.y - t.y;
                                    const d = Math.hypot(dx, dy);
                                    if (d <= t.range) {
                                        ally.hp = Math.min(
                                            ally.maxHp,
                                            ally.hp + def.heal
                                        );
                                        healed = true;
                                    }
                                }
                            });

                            // Se n√£o curou ningu√©m, ataca
                            if (!healed && target.hp > 0) {
                                const killed = applyDamage(target, t.damage);
                                if (killed && list === allies && target !== castleTarget) {
                                    money += rewardForKill[target.type] || 0;
                                }
                                if (target === castleTarget) {
                                    money += 10;
                                    castleTarget.lastHitTime = ts;
                                    checkEndConditions();
                                }

                                // üî∏ Se matou tropa inimiga
                                if (
                                    target !== castleTarget &&
                                    target.hp <= 0 &&
                                    list === allies
                                ) {
                                    const arr = list === allies ? enemies : allies;
                                    const index = arr.indexOf(target);
                                    if (index !== -1) {
                                        arr.splice(index, 1);
                                        money += rewardForKill[target.type] || 0;
                                        console.log(
                                            `üí• Curador matou ${target.type}, ganhou moedas! Total: ${money}`
                                        );
                                    }
                                }

                                // üî∏ Se atacou castelo inimigo e ele morreu
                                if (target === castleTarget) {
                                    // O curador ganha 10 moedas toda vez que ataca o castelo
                                    money += 10;
                                    castleTarget.lastHitTime = ts;
                                    console.log(
                                        `üí• Curador atacou o castelo inimigo! Ganhou 10 moedas. Total: ${money}`
                                    );
                                    checkEndConditions();
                                }
                            }

                            t.lastAttack = ts;
                        }
                        // Assassino: ataque corpo-a-corpo furtivo
                        else if (
                            t.type === "assassino" &&
                            minD <= t.range &&
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            // executa toda l√≥gica de invisibilidade / first‚Äêhit / rehide
                            const killed = assassinoAttackLogic(t, target, ts);

                            // mant√©m as recompensas/extras originais
                            if (killed && target !== castleTarget && list === allies) {
                                money += rewardForKill[target.type] || 0;
                                console.log(
                                    `üí• Assassino matou ${target.type}, ganhou moedas! Total: ${money}`
                                );
                            }

                            if (target === castleTarget) {
                                money += 10; // Ganha 10 moedas por atacar o castelo
                                castleTarget.lastHitTime = ts;
                                console.log(
                                    `üí• Assassino atacou o castelo! Ganhou 10 moedas. Total: ${money}`
                                );
                                checkEndConditions();
                            }

                            // atualiza o lastAttack (mant√©m o cooldown)
                            t.lastAttack = ts;
                        }
                        // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Ataque do Golem ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
                        else if (
                            t.type === "golem" &&
                            minD <= t.range &&              // <-- aqui
                            ts - t.lastAttack >= t.attackSpeed
                        ) {

                            // s√≥ ataca corpo-a-corpo a 30px (def.range j√° √© 30)
                            let dmg = t.damage; // base 200
                            // 4√ó de dano contra assassino ou espadachim
                            if (target.type === "assassino" || target.type === "espadachim") {
                                dmg *= 4; // vira 800
                            }
                            const killed = applyDamage(target, dmg);
                            t.lastAttack = ts;

                            // recompensa normal por tropa morta
                            if (killed && list === allies && target !== castleTarget) {
                                money += rewardForKill[target.type] || 0;
                            }
                            // recompensa extra se for o Golem que matou
                            if (killed && list === allies) {
                                money += rewardForKill.golem; // 380
                            }

                            // dano ao castelo inimigo
                            if (target === castleTarget) {
                                money += 10;
                                castleTarget.lastHitTime = ts;
                                checkEndConditions();
                            }
                        }

                        else if (
                            t.type === "chefe" &&
                            minD <= t.range &&
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            // aplica dano de corpo-a-corpo
                            const killed = applyDamage(target, t.damage);
                            t.lastAttack = ts;

                            // se matou uma tropa inimiga, d√° recompensa
                            if (killed && list === allies && target !== castleTarget) {
                                money += rewardForKill[target.type] || 0;
                            }

                            // se acertou o castelo inimigo, d√° 10ü™ô e atualiza lastHit
                            if (target === castleTarget) {
                                money += 10;
                                castleTarget.lastHitTime = ts;
                                checkEndConditions();
                            }
                        }

                        else if (
                            t.type === "esqueleto" &&
                            minD <= t.range &&              // dentro do alcance de 15px
                            ts - t.lastAttack >= t.attackSpeed
                        ) {
                            // dano proporcional ao DPS (damage √© por segundo, attackSpeed em ms)
                            const killed = applyDamage(
                                target,
                                t.damage * (t.attackSpeed / 1000)
                            );
                            t.lastAttack = ts;

                            // se matou tropa inimiga e for aliado, recompensa normal
                            if (killed && list === allies && target !== castleTarget) {
                                money += rewardForKill[target.type] || 0;
                            }

                            // se acertou o castelo, 10 moedas e atualiza lastHitTime
                            if (target === castleTarget) {
                                money += 10;
                                castleTarget.lastHitTime = ts;
                                checkEndConditions();
                            }
                        }
                    }
                });
            }

            const tornadoDef = towerDefs.tower_vento.tornado;

            // para aliados, as torres inimigas tamb√©m s√£o alvos
            const enemyTowers = towerSlots
                .map(s => s.occupied)
                .map((t, i) => ({ t, i }))       // pega tamb√©m o √≠ndice
                .filter(({ t, i }) => i >= 3 && t && t.hp > 0)  // √≠ndices 3,4,5 s√£o slots vermelhos
                .map(({ t }) => t);              // volta s√≥ a torre

            moveTroops(allies, [...enemies, ...enemyTowers], castles.red);

            // para inimigos, as torres aliadas s√£o alvos
            const allyTowers = towerSlots
                .map(s => s.occupied)
                .map((t, i) => ({ t, i }))
                .filter(({ t, i }) => i < 3 && t && t.hp > 0)   // √≠ndices 0,1,2 s√£o slots verdes
                .map(({ t }) => t);

            moveTroops(enemies, [...allies, ...allyTowers], castles.green);



            checkEndConditions();

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                // S√≥ processa o efeito do tornado para proj√©teis do tipo tornado
                if (p.type === "tornado") {
                    if (ts - p.spawnTime > towerDefs.tower_vento.tornado.lifetime) {
                        projectiles.splice(i, 1);
                        continue;
                    }

                    p.x += (p.dx || 0) * dt;
                    p.y += (p.dy || 0) * dt;

                    // Determina quem √© o alvo do tornado
                    // Se veio de slot 0,1,2 (dx < 0), √© tornado do jogador => puxa enemies
                    // Se veio de slot 3,4,5 (dx > 0), √© tornado do inimigo => puxa allies
                    const tornadoTargets = (p.dx < 0) ? enemies : allies;

                    tornadoTargets.forEach(u => {
                        // REMOVE ESSA LINHA: if (u.type === "assassino" && u.invisible) return;
                        const dx = u.x - p.x;
                        const dy = u.y - p.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 50) {
                            // PUX√ÉO MUITO FORTE: joga a tropa direto para o centro do tornado!
                            // (ou, se quiser, pode fazer ir 90% do caminho para o centro a cada frame)
                            u.x += (p.x - u.x) * 0.9;
                            u.y += (p.y - u.y) * 0.9;
                            // Dano cont√≠nuo (mant√©m igual)
                            if (!u._lastTornadoHit) u._lastTornadoHit = ts;
                            const secs = Math.floor((ts - u._lastTornadoHit) / 1000);
                            if (secs > 0) {
                                const realSecs = Math.min(secs, 1);
                                u.hp = Math.max(0, u.hp - towerDefs.tower_vento.tornado.damagePerSec * secs);
                                u._lastTornadoHit += secs * 1000;
                                if (u.hp === 0) {
                                    // D√° recompensa se for inimigo
                                    let idxE = enemies.indexOf(u);
                                    if (u.hp === 0) {
                                        // D√° recompensa se for inimigo
                                        let idxE = enemies.indexOf(u);
                                        if (idxE !== -1) {
                                            money += rewardForKill[u.type] || 0;
                                            elixir += rewardElixir[u.type] || 0;
                                            enemies.splice(idxE, 1);
                                        }
                                        let idxA = allies.indexOf(u);
                                        if (idxA !== -1) allies.splice(idxA, 1);
                                    }
                                    let idxA = allies.indexOf(u);
                                    if (idxA !== -1) allies.splice(idxA, 1);
                                }
                            }
                        }
                    });
                    continue;
                }

                // Move o proj√©til
                p.x += (p.vx || 0) * dt;
                p.y += (p.vy || 0) * dt;


                // Remover se sair do mundo
                if (p.x < 0 || p.x > WORLD_SIZE || p.y < 0 || p.y > WORLD_SIZE) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // === Verifica colis√£o com castelo ===
                if (p.side === "ally") {
                    const dx = p.x - castles.red.x;
                    const dy = p.y - castles.red.y;
                    if (Math.hypot(dx, dy) < 70) {
                        castles.red.hp -= p.damage;
                        castles.red.lastHitTime = performance.now();
                        money += 10;
                        checkEndConditions();
                        console.log(
                            "üí∞ Ganhou 10 moedas ao atingir castelo vermelho:",
                            money
                        );
                        p.pierced = (p.pierced || 0) + 1;
                        if (p.pierced >= p.pierce) projectiles.splice(i, 1);
                        continue;
                    }
                } else {
                    const dx = p.x - castles.green.x;
                    const dy = p.y - castles.green.y;
                    if (Math.hypot(dx, dy) < 70) {
                        castles.green.hp -= p.damage;
                        p.pierced = (p.pierced || 0) + 1;
                        if (p.pierced >= p.pierce) projectiles.splice(i, 1);
                        continue;
                    }
                }

                // === Verifica colis√£o com torres inimigas ===
                const towerList = p.side === "ally"
                    ? towerSlots.map((s, i) => i >= 3 ? s.occupied : null) // aliados s√≥ atingem torres inimigas (√≠ndices 3,4,5)
                    : towerSlots.map((s, i) => i < 3 ? s.occupied : null); // inimigos s√≥ atingem torres do jogador (√≠ndices 0,1,2)
                for (const tw of towerList) {
                    if (!tw || tw.hp <= 0) continue;
                    const dx = p.x - tw.x, dy = p.y - tw.y;
                    if (Math.hypot(dx, dy) < 25) {
                        applyDamage(tw, p.damage);
                        p.pierced = (p.pierced || 0) + 1;
                        if (p.pierced >= p.pierce) projectiles.splice(i, 1);
                        break;
                    }
                }


                // === Verifica colis√£o com tropas ===
                const targets = p.side === "ally" ? enemies : allies;
                for (let j = 0; j < targets.length; j++) {
                    const t = targets[j];
                    if (p.hitTargets && p.hitTargets.includes(t.id)) continue; // CORRIGIDO

                    const dx = t.x - p.x;
                    const dy = t.y - p.y;
                    const d = Math.hypot(dx, dy);
                    if (d < 16) {
                        let realDmg = p.damage;

                        if (p.hitTargets.includes(t.id)) {
                            break;     // ou continue, mas cuidado para n√£o entrar em loop infinito
                        }

                        // Se for magia de mago (tem slowFactor) e o alvo √© chefe ou golem
                        if (p.slowFactor) {
                            if (t.type === "chefe") {
                                realDmg *= 4;
                            } else if (t.type === "golem") {
                                realDmg *= 1.5;
                            }
                        }

                        p.hitTargets.push(t.id);

                        const killed = applyDamage(t, realDmg);
                        if (killed && p.side === "ally") {
                            money += rewardForKill[t.type] || 0;
                        }

                        // aplica efeito de lentid√£o:
                        if (p.slowFactor && t.type !== "castelo") {
                            t.originalSpeed = troopDefs[t.type].speed;
                            t.speed = t.originalSpeed * p.slowFactor;
                            t.slowExpires = performance.now() + p.slowDuration;
                        }

                        p.pierced = (p.pierced || 0) + 1;

                        // Se j√° perfurou o m√°ximo de alvos, remove
                        if (p.pierced >= p.pierce) {
                            projectiles.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }

        // 5) drawTroop(t, side): rotaciona sprite segundo t._angle
        function drawTroop(t, side) {
            if (side === "ally" && t.type === "assassino" && t.invisible) {
                return;
            }

            // somente invis√≠veis **inimigos** ganham ghost bar
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2) Inimigo invis√≠vel: ghost‚Äêbar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (side === "enemy" && t.type === "assassino" && t.invisible) {
                const sx = t.x - camera.x;
                const sy = t.y - camera.y;
                // pct entre 0 e 1
                const pct = Math.max(
                    0,
                    Math.min(1, t.hp / troopDefs.assassino.maxHp)
                );
                const hpW = 40 * pct;
                // fundo cinza
                ctx.fillStyle = "rgba(100,100,100,0.5)";
                ctx.fillRect(sx - 20, sy - 30, 40, 6);
                // barra vermelha
                ctx.fillStyle = "rgba(255,0,0,0.7)";
                ctx.fillRect(sx - 20, sy - 30, hpW, 6);
                return;
            }

            const def = troopDefs[t.type];
            const sx = t.x - camera.x;
            const sy = t.y - camera.y;
            const size = (t.type === "chefe" ? 128 : 32);
            // se n√£o houver √¢ngulo ainda (por ex. acabou de spawnar), assume 0
            const angle = t._angle || 0;
            // componente X do vetor de movimento
            const dirX = Math.cos(angle);

            ctx.save();
            ctx.translate(sx, sy);

            // Se estiver indo para a esquerda, espelha horizontalmente
            if (dirX < 0) {
                ctx.scale(-1, 1);
            }

            // Desenha sempre sem rota√ß√£o ‚Äî o sprite virado para a direita
            // ser√° espelhado se dirX<0, ou normal se dirX>=0
            ctx.drawImage(def.img, -size / 2, -size / 2, size, size);

            ctx.restore();

            // barra de vida
            const hpW = 40 * (t.hp / t.maxHp);
            ctx.fillStyle = "gray";
            ctx.fillRect(sx - 20, sy - 30, 40, 6);
            ctx.fillStyle =
                side === "ally" ? (t.type === "curador" ? "blue" : "green") : "red";
            ctx.fillRect(sx - 20, sy - 30, hpW, 6);

            if (t.isEvo) {
                ctx.save();
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = "blue";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, 30, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

        }

        function gameLoop(ts) {
            updatePowerUpButtons();
            update(ts, ctx);
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.getElementById("btnToggleShop").addEventListener("click", () => {
            const shop = document.getElementById("shop");
            shop.style.display = shop.style.display === "none" ? "block" : "none";
        });


        // Menu de dificuldade
        document.querySelectorAll("#menu button").forEach((btn) => {
            btn.addEventListener("click", (e) => {
                const diff = e.target.dataset.diff;
                startGame(diff);
                alert(
                    "Para mover a c√¢mera, arraste o game para cima, para baixo, para a esquerda e para a direita.\n\n" +
                    "Siga a bolinha verde para encontrar o seu castelo!"
                );
                requestAnimationFrame(gameLoop);
                document.getElementById("menu").style.display = "none";
            });
        });

        const selectType = document.getElementById("modTroopType");
        const checkboxEvo = document.getElementById("modTroopEvo");
        const btnModMenu = document.getElementById("btnModMenu");


        let modMenuClicks = 0;
        document.getElementById("btnModMenu").onclick = function () {
            modMenuClicks++;
            if (modMenuClicks >= 3) {
                openModMenu();
                modMenuClicks = 0;
            }
        };

        if (sessionStorage.getItem("victory") === "true") {
            document.getElementById("btnModMenu").style.display = "block";
        }

        function adjustCanvasSize() {
            let w = window.innerWidth;
            let h = window.innerHeight;
            if (w > 950) w = 950;
            if (h > 450) h = 450;
            canvas.width = w;
            canvas.height = h;
            clampCamera();
            draw();
        }

        // Chame aqui, depois da defini√ß√£o:
        adjustCanvasSize();

        // E mantenha o listener de resize:
        window.addEventListener("resize", adjustCanvasSize);

        function openModMenu() {
            // Cria overlay
            let overlay = document.createElement("div");
            overlay.id = "modMenuOverlay";
            overlay.style.position = "fixed";
            overlay.style.top = 0;
            overlay.style.left = 0;
            overlay.style.width = "100vw";
            overlay.style.height = "100vh";
            overlay.style.background = "rgba(0,0,0,0.7)";
            overlay.style.zIndex = 3000;
            overlay.style.display = "flex";
            overlay.style.alignItems = "center";
            overlay.style.justifyContent = "center";

            // Menu principal
            let menu = document.createElement("div");
            menu.style.background = "#222";
            menu.style.color = "#fff";
            menu.style.padding = "24px";
            menu.style.borderRadius = "12px";
            menu.style.fontFamily = "sans-serif";
            menu.style.minWidth = "340px";
            menu.innerHTML = `
        <h2>Mod Menu - Invocar Tropa</h2>
        <label>Tipo de tropa:
            <select id="modTroopType">
                <option value="arqueiro">Arqueiro</option>
                <option value="espadachim">Espadachim</option>
                <option value="golem">Golem</option>
                <option value="assassino">Assassino</option>
                <option value="chefe">Chefe</option>
                <option value="mago">Mago</option>
                <option value="curador">Curador</option>
            </select>
        </label>
        <!-- Checkbox para evolu√≠do -->
       <span id="modEvoLabel" style="margin-left:12px;">
         √â uma evo?
         <input type="checkbox" id="modTroopEvo" />
        </span>
        <br>
        <label>Lado:
            <select id="modTroopSide">
                <option value="enemy">Inimigo</option>
                <option value="ally">Aliado</option>
            </select>
        </label>
        <br>
        <label>Vida: <input id="modTroopHp" type="number" min="1"></label><br>
        <label>Dano: <input id="modTroopDmg" type="number" min="1"></label><br>
        <label>Speed: <input id="modTroopSpeed" type="number" min="1"></label><br>
        <label>Alcance: <input id="modTroopRange" type="number" min="1"></label><br>
        <label>Velocidade de ataque (ms): <input id="modTroopAtkSpd" type="number" min="1"></label><br>
        <button id="modMenuPronto">Pronto</button>
        <button id="modMenuFechar">Fechar</button>
        <div id="modMenuStats" style="margin-top:10px;font-size:13px;color:#aaa"></div>
    `;

            const selectType = menu.querySelector("#modTroopType");
            const checkboxEvo = menu.querySelector("#modTroopEvo");
            const hpInput = menu.querySelector("#modTroopHp");
            const dmgInput = menu.querySelector("#modTroopDmg");
            const speedInput = menu.querySelector("#modTroopSpeed");
            const rangeInput = menu.querySelector("#modTroopRange");
            const atkSpdInput = menu.querySelector("#modTroopAtkSpd");
            const statsDiv = menu.querySelector("#modMenuStats");

            const evoLabel = menu.querySelector("#modEvoLabel");

            overlay.appendChild(menu);
            document.body.appendChild(overlay);

            // Atualiza stats base ao trocar tipo
            function updateStats() {
                const type = selectType.value;
                const isEvo = checkboxEvo.checked;

                const def = (isEvo && evolution[type]?.stats) ? evolution[type].stats : troopDefs[type];

                if (["arqueiro", "curador", "assassino"].includes(type)) {
                    evoLabel.style.display = "";
                } else {
                    evoLabel.style.display = "none";
                    checkboxEvo.checked = false;
                }

                hpInput.placeholder = def.maxHp ?? def.hp;
                dmgInput.placeholder = def.damage;
                speedInput.placeholder = def.speed;
                rangeInput.placeholder = def.range;
                atkSpdInput.placeholder = def.attackSpeed ?? troopDefs[type].attackSpeed;


                statsDiv.innerHTML =
                    `Tipo de tropa: <b>${type}${isEvo ? " (EVO)" : ""}</b><br>
                Vida: ${def.maxHp ?? def.hp}<br>
                Dano: ${def.damage}<br>
                Speed: ${def.speed}<br>
                Alcance: ${def.range}<br>
                Velocidade de ataque: ${def.attackSpeed} ms`;
            }


            document.getElementById("modTroopType").onchange = updateStats;
            selectType.onchange = updateStats;
            checkboxEvo.onchange = updateStats;
            updateStats();

            // Fechar
            document.getElementById("modMenuFechar").onclick = () => {
                overlay.remove();
            };

            // Pronto
            // ...dentro do onclick do #modMenuPronto...
            document.getElementById("modMenuPronto").onclick = () => {
                const type = document.getElementById("modTroopType").value;
                const isEvoRequested = document.getElementById("modTroopEvo").checked;
                const side = document.getElementById("modTroopSide").value;
                const canEvolve = ["arqueiro", "curador", "assassino"];
                const spawnEvo = canEvolve.includes(type) && isEvoRequested;

                // Pega os valores digitados
                const hpInput = document.getElementById("modTroopHp").value;
                const dmgInput = document.getElementById("modTroopDmg").value;
                const speedInput = document.getElementById("modTroopSpeed").value;
                const rangeInput = document.getElementById("modTroopRange").value;
                const atkSpdInput = document.getElementById("modTroopAtkSpd").value;

                // Come√ßa com stats base
                let baseStats = troopDefs[type];
                if (spawnEvo && evolution[type]) {
                    baseStats = { ...baseStats, ...evolution[type].stats };
                }

                // Aplica o que foi digitado por cima dos stats base/EVO
                const hp = hpInput !== "" ? Number(hpInput) : baseStats.maxHp ?? baseStats.hp;
                const dmg = dmgInput !== "" ? Number(dmgInput) : baseStats.damage;
                const speed = speedInput !== "" ? Number(speedInput) : baseStats.speed;
                const range = rangeInput !== "" ? Number(rangeInput) : baseStats.range;
                const atkSpd = atkSpdInput !== "" ? Number(atkSpdInput) : baseStats.attackSpeed;

                // Cria a tropa customizada
                const t = {
                    type,
                    x: side === "enemy" ? castles.red.x : castles.green.x,
                    y: side === "enemy" ? castles.red.y : castles.green.y,
                    hp,
                    maxHp: hp,
                    damage: dmg,
                    speed,
                    range,
                    attackSpeed: atkSpd,
                    lastAttack: performance.now(),
                    _angle: 0
                };
                t.id = nextTroopId++;
                if (type === "assassino") {
                    t.invisible = true;
                    t.invisibleUntil = performance.now() + 15000;
                    t.firstHit = true;
                }
                if (type === "chefe") {
                    t.lastSkeleton = performance.now();
                    t.skeletonCount = 0;
                    t.triggers = { 80: false, 60: false, 40: false, 20: false };
                }
                if (spawnEvo) {
                    t.isEvo = true;
                    if (type === "assassino") {
                        t.firstHitDamage = evolution.assassino.stats.firstHitDamage;
                    }
                }
                if (side === "enemy") enemies.push(t);
                else allies.push(t);

                overlay.remove();
            };
        }

        if (window.innerWidth < 577 || window.innerHeight < 349) {
            alert("‚ö†Ô∏è Seu dispositivo pode n√£o ser ideal para jogar. A interface pode n√£o caber corretamente na tela.");
        }

        // Redesenha sempre que a janela for redimensionada
        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            clampCamera();
            draw();
        });

        // Inicializa√ß√£o
        window.dispatchEvent(new Event("resize"));

        renderShop();
    </script>
</body>


</html>
